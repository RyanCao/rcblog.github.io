<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蚂蚁博客</title>
  
  <subtitle>Devlopper in C#</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.rcant.com/"/>
  <updated>2020-08-26T03:31:03.302Z</updated>
  <id>http://blog.rcant.com/</id>
  
  <author>
    <name>Chester.C</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSharp ApiDoc 自动生成API文档</title>
    <link href="http://blog.rcant.com/2020/08/26/csharp/csharp-docfx/"/>
    <id>http://blog.rcant.com/2020/08/26/csharp/csharp-docfx/</id>
    <published>2020-08-26T03:39:17.000Z</published>
    <updated>2020-08-26T03:31:03.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>同于生成API文档记录</p><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://dotnet.github.io/docfx/tutorial/docfx_getting_started.html" target="_blank" rel="noopener">Docfx Getting Started</a></li></ul><h2 id="安装DocFx"><a href="#安装DocFx" class="headerlink" title="安装DocFx"></a>安装DocFx</h2><h3 id="使用-Chocolatey-安装"><a href="#使用-Chocolatey-安装" class="headerlink" title="使用 Chocolatey 安装"></a>使用 Chocolatey 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install docfx -y.</span><br></pre></td></tr></table></figure><h3 id="使用-Homebrew-安装"><a href="#使用-Homebrew-安装" class="headerlink" title="使用 Homebrew 安装"></a>使用 Homebrew 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install docfx.</span><br></pre></td></tr></table></figure><h3 id="去GitHub下载文件安装"><a href="#去GitHub下载文件安装" class="headerlink" title="去GitHub下载文件安装"></a>去GitHub下载文件安装</h3><ul><li>从GitHub <a href="https://github.com/dotnet/docfx/releases" target="_blank" rel="noopener">DocFx 下载</a> 文件 docfx.zip</li><li>解压文件docfx.zip</li><li>添加到环境变量Path中</li></ul><h2 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h2><p>使用命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docfx.exe --version</span><br><span class="line">docfx 2.56.2.0</span><br><span class="line">Copyright (C) 2020 ? Microsoft Corporation. All rights reserved.</span><br><span class="line">This is open-source software under MIT License.</span><br></pre></td></tr></table></figure><h2 id="使用-Visual-Studio-集成-DocFx"><a href="#使用-Visual-Studio-集成-DocFx" class="headerlink" title="使用 Visual Studio 集成 DocFx"></a>使用 Visual Studio 集成 DocFx</h2><ul><li>使用Visual Studio 创建  Class Library (.NET Framework) 项目</li></ul><h2 id="使用DocFx"><a href="#使用DocFx" class="headerlink" title="使用DocFx"></a>使用DocFx</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;同于生成API文档记录&lt;/p&gt;
    
    </summary>
    
      <category term="CSharp" scheme="http://blog.rcant.com/categories/CSharp/"/>
    
    
      <category term="CSharp" scheme="http://blog.rcant.com/tags/CSharp/"/>
    
      <category term="ApiDoc" scheme="http://blog.rcant.com/tags/ApiDoc/"/>
    
      <category term="DocFx" scheme="http://blog.rcant.com/tags/DocFx/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs安装</title>
    <link href="http://blog.rcant.com/2020/08/07/js/nodejs-first/"/>
    <id>http://blog.rcant.com/2020/08/07/js/nodejs-first/</id>
    <published>2020-08-07T06:40:07.000Z</published>
    <updated>2020-08-07T07:03:45.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>安装NodeJs</p><a id="more"></a><h2 id="Node安装"><a href="#Node安装" class="headerlink" title="Node安装"></a>Node安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>官网下载<br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>我用的是v6.10<br>安装完使用 node -v 验证下</p><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><ol><li>安装 homebrew</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>brew 升级</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><ol start="3"><li>确保brew安全可靠</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew doctor</span><br></pre></td></tr></table></figure><ol start="4"><li><p>修复警告</p></li><li><p>通过brew安装node和npm</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew link node</span><br><span class="line">brew uninstall node</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><h3 id="替换brew镜像源"><a href="#替换brew镜像源" class="headerlink" title="替换brew镜像源"></a>替换brew镜像源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-cask&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure><h2 id="替换nodejs镜像源"><a href="#替换nodejs镜像源" class="headerlink" title="替换nodejs镜像源"></a>替换nodejs镜像源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设置 淘宝镜像源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">// 查看 使用的 镜像源</span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line">// 安装 淘宝镜像源</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;安装NodeJs&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.rcant.com/categories/js/"/>
    
    
      <category term="nodejs,js" scheme="http://blog.rcant.com/tags/nodejs-js/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 安装HomeBrew</title>
    <link href="http://blog.rcant.com/2020/08/07/osx/os-brew/"/>
    <id>http://blog.rcant.com/2020/08/07/osx/os-brew/</id>
    <published>2020-08-07T06:40:07.000Z</published>
    <updated>2020-08-07T07:51:02.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>安装HomeBrew，Mac用的少，记录下，以免忘记</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="方式1-简单的脚本安装brew-网络正常访问raw-githubusercontent-com"><a href="#方式1-简单的脚本安装brew-网络正常访问raw-githubusercontent-com" class="headerlink" title="方式1. 简单的脚本安装brew [网络正常访问raw.githubusercontent.com]"></a>方式1. 简单的脚本安装brew [网络正常访问raw.githubusercontent.com]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="方式2-ruby-shell-网络正常访问raw-githubusercontent-com"><a href="#方式2-ruby-shell-网络正常访问raw-githubusercontent-com" class="headerlink" title="方式2. ruby shell [网络正常访问raw.githubusercontent.com]"></a>方式2. ruby shell [网络正常访问raw.githubusercontent.com]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><blockquote><p>由于网络资源的原因，国内使用上面的方式很慢，经常失败，解决办法以下两种</p></blockquote><h3 id="方式3-替换镜像源"><a href="#方式3-替换镜像源" class="headerlink" title="方式3. 替换镜像源"></a>方式3. 替换镜像源</h3><h3 id="方式4-使用全局代理-挂VPN"><a href="#方式4-使用全局代理-挂VPN" class="headerlink" title="方式4. 使用全局代理(挂VPN)"></a>方式4. 使用全局代理(挂VPN)</h3><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="1-如果出现错误"><a href="#1-如果出现错误" class="headerlink" title="1. 如果出现错误"></a>1. 如果出现错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &apos;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&apos;...</span><br><span class="line"></span><br><span class="line">fatal: unable to access &apos;https://github.com/Homebrew/homebrew-core/&apos;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 </span><br><span class="line"></span><br><span class="line">Error: Failure while executing: git clone https://github.com/Homebrew/homebrew-core /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1</span><br><span class="line"></span><br><span class="line">Error: Failure while executing: /usr/local/bin/brew tap homebrew/core</span><br><span class="line"></span><br><span class="line">Failed during: /usr/local/bin/brew update --force</span><br></pre></td></tr></table></figure><p>可以手动下载国内仓库</p><h4 id="安装brew："><a href="#安装brew：" class="headerlink" title="安装brew："></a>安装brew：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/Homebrew/Library/Taps/homebrew</span><br><span class="line">git clone git://mirrors.ustc.edu.cn/homebrew-core.git /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1</span><br></pre></td></tr></table></figure><h4 id="安装brew-cask："><a href="#安装brew-cask：" class="headerlink" title="安装brew cask："></a>安装brew cask：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://mirrors.ustc.edu.cn/homebrew-cask.git /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask --depth=1</span><br></pre></td></tr></table></figure><h3 id="2-如果出现错误-raw-githubusercontent-com-无法访问"><a href="#2-如果出现错误-raw-githubusercontent-com-无法访问" class="headerlink" title="2. 如果出现错误 raw.githubusercontent.com 无法访问"></a>2. 如果出现错误 raw.githubusercontent.com 无法访问</h3><p>可以去网站 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 查询raw.githubusercontent.com 地址<br>如下图所示</p><img src="/2020/08/07/osx/os-brew/ipfound.png" title="Ip查找"><p>修改hosts, 添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><h2 id="替换brew镜像源"><a href="#替换brew镜像源" class="headerlink" title="替换brew镜像源"></a>替换brew镜像源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-cask&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure><h2 id="卸载brew"><a href="#卸载brew" class="headerlink" title="卸载brew"></a>卸载brew</h2><h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall.sh)&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;安装HomeBrew，Mac用的少，记录下，以免忘记&lt;/p&gt;
    
    </summary>
    
      <category term="osx" scheme="http://blog.rcant.com/categories/osx/"/>
    
    
      <category term="osx" scheme="http://blog.rcant.com/tags/osx/"/>
    
  </entry>
  
  <entry>
    <title>VSCode+GoLang 环境搭建</title>
    <link href="http://blog.rcant.com/2020/06/13/golang/golang-vscode/"/>
    <id>http://blog.rcant.com/2020/06/13/golang/golang-vscode/</id>
    <published>2020-06-13T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.893Z</updated>
    
    <content type="html"><![CDATA[<p>Window 上建立Golang开发环境记录</p><a id="more"></a><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul><li>Windows操作系统</li><li>go 1.14</li><li>VSCode 1.46</li></ul><h2 id="下载并安装软件"><a href="#下载并安装软件" class="headerlink" title="下载并安装软件"></a>下载并安装软件</h2><ul><li>略</li></ul><h2 id="设置-go-环境变量"><a href="#设置-go-环境变量" class="headerlink" title="设置 go 环境变量"></a>设置 go 环境变量</h2><p>系统环境变量中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GOROOT=C:\Go</span><br><span class="line">GOBIN=C:\Go\bin</span><br></pre></td></tr></table></figure><p>系统环境变量 Path 变量中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%GOBIN%</span><br></pre></td></tr></table></figure><p>用户环境变量中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPATH=%USERPROFILE%\go</span><br></pre></td></tr></table></figure><h2 id="安装-VSCode-go-插件"><a href="#安装-VSCode-go-插件" class="headerlink" title="安装 VSCode-go 插件"></a>安装 VSCode-go 插件</h2><img src="/2020/06/13/golang/golang-vscode/vscode-plugin.png" title="VSCode插件"><h2 id="修改-golang-镜像地址"><a href="#修改-golang-镜像地址" class="headerlink" title="修改 golang 镜像地址"></a>修改 golang 镜像地址</h2><h3 id="Go-1-13-及以上（推荐）"><a href="#Go-1-13-及以上（推荐）" class="headerlink" title="Go 1.13 及以上（推荐）"></a>Go 1.13 及以上（推荐）</h3><p>打开你的终端并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h3 id="Windows-环境下修改"><a href="#Windows-环境下修改" class="headerlink" title="Windows 环境下修改"></a>Windows 环境下修改</h3><ol><li>打开“开始”并搜索“env”</li><li>选择“编辑系统环境变量”</li><li>点击“环境变量…”按钮</li><li>在“&lt;你的用户名&gt; 的用户变量”章节下（上半部分）</li><li>点击“新建…”按钮</li><li>选择“变量名”输入框并输入“GOPROXY”</li><li>选择“变量值”输入框并输入“<a href="https://goproxy.cn”" target="_blank" rel="noopener">https://goproxy.cn”</a></li><li>点击“确定”按钮</li></ol><h3 id="Linux-环境下修改"><a href="#Linux-环境下修改" class="headerlink" title="Linux 环境下修改"></a>Linux 环境下修改</h3><p>打开你的终端并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile &amp;&amp; source ~/.profile</span><br></pre></td></tr></table></figure><p>完成。</p><h2 id="安装-golang-插件"><a href="#安装-golang-插件" class="headerlink" title="安装 golang 插件"></a>安装 golang 插件</h2><p>Ctrl + Shift + P</p><p>打开命令，输入 go:install</p><img src="/2020/06/13/golang/golang-vscode/go-plugin-1.png" title="go:install/update tools"><p>选择 go:install/update tools</p><img src="/2020/06/13/golang/golang-vscode/go-plugin-2.png" title="go-plugins"><h2 id="配置-golang-自动补全功能"><a href="#配置-golang-自动补全功能" class="headerlink" title="配置 golang 自动补全功能"></a>配置 golang 自动补全功能</h2><p>setting.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;go.addTags&quot;: &#123;&#125;,</span><br><span class="line">    &quot;window.zoomLevel&quot;: 1,</span><br><span class="line">    &quot;go.autocompleteUnimportedPackages&quot;: true,</span><br><span class="line">    &quot;go.gocodePackageLookupMode&quot;: &quot;go&quot;,</span><br><span class="line">    &quot;go.gotoSymbol.includeImports&quot;: true,</span><br><span class="line">    &quot;go.useCodeSnippetsOnFunctionSuggest&quot;: true,</span><br><span class="line">    &quot;go.inferGopath&quot;: false,</span><br><span class="line">    &quot;go.gopath&quot;: &quot;C:\\Users\\xxx\\go&quot;,</span><br><span class="line">    &quot;go.useCodeSnippetsOnFunctionSuggestWithoutType&quot;: true,</span><br><span class="line">    &quot;files.autoSave&quot;:&quot;onFocusChange&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Window 上建立Golang开发环境记录&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.rcant.com/categories/python/"/>
    
    
      <category term="golang" scheme="http://blog.rcant.com/tags/golang/"/>
    
      <category term="vscode" scheme="http://blog.rcant.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>VSCode+Python 环境搭建</title>
    <link href="http://blog.rcant.com/2020/06/03/python/python3-vscode/"/>
    <id>http://blog.rcant.com/2020/06/03/python/python3-vscode/</id>
    <published>2020-06-03T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.909Z</updated>
    
    <content type="html"><![CDATA[<p>Window 上建立python开发环境记录</p><a id="more"></a><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul><li>Windows操作系统</li><li>python 3.6</li><li>VSCode 1.46</li></ul><h2 id="下载并安装软件"><a href="#下载并安装软件" class="headerlink" title="下载并安装软件"></a>下载并安装软件</h2><ul><li>略</li></ul><h2 id="设置-python-环境变量"><a href="#设置-python-环境变量" class="headerlink" title="设置 python 环境变量"></a>设置 python 环境变量</h2><p>系统环境变量中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PythonHome=C:\Python36</span><br></pre></td></tr></table></figure><p>系统环境变量 Path 变量中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%PythonHome%</span><br><span class="line">%PythonHome%\Scripts</span><br></pre></td></tr></table></figure><h2 id="安装VSCode-python插件"><a href="#安装VSCode-python插件" class="headerlink" title="安装VSCode python插件"></a>安装VSCode python插件</h2><img src="/2020/06/03/python/python3-vscode/vscode-plugin.png" title="VSCode插件"><h2 id="修改python-pip-镜像地址"><a href="#修改python-pip-镜像地址" class="headerlink" title="修改python pip 镜像地址"></a>修改python pip 镜像地址</h2><h3 id="Windows-环境下修改"><a href="#Windows-环境下修改" class="headerlink" title="Windows 环境下修改"></a>Windows 环境下修改</h3><p>vi ~/pip/pip.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">trusted-host =  mirrors.aliyun.com</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure><h3 id="Linux-环境下修改"><a href="#Linux-环境下修改" class="headerlink" title="Linux 环境下修改"></a>Linux 环境下修改</h3><p>vim ~/.pip/pip.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">trusted-host =  mirrors.aliyun.com</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure><h2 id="安装-pylint"><a href="#安装-pylint" class="headerlink" title="安装 pylint"></a>安装 pylint</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pylint</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Window 上建立python开发环境记录&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.rcant.com/categories/python/"/>
    
    
      <category term="vscode" scheme="http://blog.rcant.com/tags/vscode/"/>
    
      <category term="python3" scheme="http://blog.rcant.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 升级 Node 版本</title>
    <link href="http://blog.rcant.com/2020/06/01/hexo/hexo-updatenode/"/>
    <id>http://blog.rcant.com/2020/06/01/hexo/hexo-updatenode/</id>
    <published>2020-06-01T02:39:17.000Z</published>
    <updated>2020-08-07T08:00:55.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>电脑重装系统 重新装的新的Node，无法使用Hexo</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>Node v12.18<br>Git</p><h2 id="node-设置环境变量"><a href="#node-设置环境变量" class="headerlink" title="node 设置环境变量"></a>node 设置环境变量</h2><p>重装Node的时候最好卸载掉旧版本文件，防止冲突</p><h2 id="npm更换淘宝镜像"><a href="#npm更换淘宝镜像" class="headerlink" title="npm更换淘宝镜像"></a>npm更换淘宝镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="npm-安装-grunt-cli-hexo"><a href="#npm-安装-grunt-cli-hexo" class="headerlink" title="npm  安装 grunt-cli hexo"></a>npm  安装 grunt-cli hexo</h2><h3 id="安装-grunt-cli"><a href="#安装-grunt-cli" class="headerlink" title="安装 grunt-cli"></a>安装 grunt-cli</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g grunt-cli</span><br></pre></td></tr></table></figure><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>查看信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo-cli: 3.1.0</span><br><span class="line">os: Windows_NT 10.0.18363 win32 x64</span><br><span class="line">node: 12.18.0</span><br><span class="line">v8: 7.8.279.23-node.37</span><br><span class="line">uv: 1.37.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.16.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 6</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure><h2 id="升级错误记录"><a href="#升级错误记录" class="headerlink" title="升级错误记录"></a>升级错误记录</h2><h3 id="node-升级14-以后，hexo-部署失败了"><a href="#node-升级14-以后，hexo-部署失败了" class="headerlink" title="node 升级14 以后，hexo 部署失败了"></a>node 升级14 以后，hexo 部署失败了</h3><p>报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object</span><br><span class="line">    at copyFile (fs.js:1924:10)</span><br><span class="line">    at tryCatcher (E:\projects\hexo\rcantblog_hexo\blog\node_modules\hexo-fs\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at ret (eval at makeNodePromisifiedEval (C:\Users\cqs\AppData\Roaming\npm\node_modules\hexo\node_modules\bluebird\js\release\promisify.js:184:12), &lt;anonymous&gt;:13:39)</span><br><span class="line">    at E:\projects\hexo\rcantblog_hexo\blog\node_modules\hexo-fs\lib\fs.js:144:39</span><br><span class="line">    at tryCatcher (E:\projects\hexo\rcantblog_hexo\blog\node_modules\hexo-fs\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (E:\projects\hexo\rcantblog_hexo\blog\node_modules\hexo-fs\node_modules\bluebird\js\release\promise.js:517:31)</span><br><span class="line">    at Promise._settlePromise (E:\projects\hexo\rcantblog_hexo\blog\node_modules\hexo-fs\node_modules\bluebird\js\release\promise.js:574:18)</span><br></pre></td></tr></table></figure><p>google了下发现是hexo不支持最新node14+，issue见此，解决方案两种：降低node版本或者升级最新<a href="mailto:hexo@4.2.1" target="_blank" rel="noopener">hexo@4.2.1</a>+。</p><p>我尝试了升级hexo到4.2.1发现并没有什么卵用，照样报相同的错，所以选择了降低node版本到稳定版：</p><p>直接到官网下载最新稳定版：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p>然后重新执行 hexo clean &amp;&amp; hexo deploy 打包命令就好了。</p><p>P.S. 如果打包成功后，最好验证下hexo下的分类和标签是否正常工作，我就遇到了点击自己博客首页的「分类」和「标签」后，跳转的页面报404，原因是打开的路由最后多了个空格：./categories/%20 。不知道啥原因，所以我把hexo版本退回到了3.8.0。这样路由就正确了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;电脑重装系统 重新装的新的Node，无法使用Hexo&lt;/p&gt;
&lt;h2 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;he
      
    
    </summary>
    
      <category term="hexo" scheme="http://blog.rcant.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.rcant.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>各种国内镜像仓库地址收集</title>
    <link href="http://blog.rcant.com/2019/08/28/others/hubmirror/"/>
    <id>http://blog.rcant.com/2019/08/28/others/hubmirror/</id>
    <published>2019-08-28T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><a id="more"></a><h2 id="CentOS-yum-软件包仓库"><a href="#CentOS-yum-软件包仓库" class="headerlink" title="CentOS yum 软件包仓库"></a>CentOS yum 软件包仓库</h2><h3 id="备份默认源"><a href="#备份默认源" class="headerlink" title="备份默认源"></a>备份默认源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@user ~]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.b</span><br></pre></td></tr></table></figure><h3 id="使用阿里云镜像"><a href="#使用阿里云镜像" class="headerlink" title="使用阿里云镜像"></a>使用阿里云镜像</h3><h4 id="CentOS-5"><a href="#CentOS-5" class="headerlink" title="CentOS 5"></a>CentOS 5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo</span><br></pre></td></tr></table></figure><h4 id="CentOS-6"><a href="#CentOS-6" class="headerlink" title="CentOS 6"></a>CentOS 6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br></pre></td></tr></table></figure><h4 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><h3 id="生成对应的缓存"><a href="#生成对应的缓存" class="headerlink" title="生成对应的缓存"></a>生成对应的缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h2 id="DockerCe-更换镜像源"><a href="#DockerCe-更换镜像源" class="headerlink" title="DockerCe 更换镜像源"></a>DockerCe 更换镜像源</h2><p>配置docker-ce软件仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更换阿里云 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line">vim docker-ce.repo </span><br><span class="line"># 按ecs进行非编辑模式</span><br><span class="line">:%s/https:\/\/download.docker.com/https:\/\/mirrors.aliyun.com\/docker-ce/g</span><br></pre></td></tr></table></figure><h2 id="DockerHub-仓库"><a href="#DockerHub-仓库" class="headerlink" title="DockerHub 仓库"></a>DockerHub 仓库</h2><h3 id="配置Docker-镜像加速"><a href="#配置Docker-镜像加速" class="headerlink" title="配置Docker 镜像加速"></a>配置Docker 镜像加速</h3><h4 id="国内加速站点"><a href="#国内加速站点" class="headerlink" title="国内加速站点"></a>国内加速站点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://registry.docker-cn.com</span><br><span class="line">http://hub-mirror.c.163.com</span><br><span class="line">https://3laho3y3.mirror.aliyuncs.com</span><br><span class="line">http://f1361db2.m.daocloud.io</span><br><span class="line">https://mirror.ccs.tencentyun.com</span><br></pre></td></tr></table></figure><h4 id="使用命令来配置加速站点"><a href="#使用命令来配置加速站点" class="headerlink" title="使用命令来配置加速站点"></a>使用命令来配置加速站点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用脚本来配置加速站点"><a href="#使用脚本来配置加速站点" class="headerlink" title="使用脚本来配置加速站点"></a>使用脚本来配置加速站点</h4><p>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://raw.githubusercontent.com/wss434631143/xiaoshujiang/master/articles/Docker/shell/set_mirror.sh | sh -s &lt;your accelerate address&gt;</span><br></pre></td></tr></table></figure><h4 id="通过修改启动脚本配置加速站点"><a href="#通过修改启动脚本配置加速站点" class="headerlink" title="通过修改启动脚本配置加速站点"></a>通过修改启动脚本配置加速站点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 直接修改 /usr/lib/systemd/system/docker.service 启动脚本</span><br><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line"># 在dockerd后面加参数</span><br><span class="line">ExecStart=/usr/bin/dockerd --registry-mirror=&lt;your accelerate address&gt;</span><br></pre></td></tr></table></figure><p>以上操作后重启一下 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="pip-软件包仓库"><a href="#pip-软件包仓库" class="headerlink" title="pip 软件包仓库"></a>pip 软件包仓库</h2><h3 id="pip改用阿里云镜像源"><a href="#pip改用阿里云镜像源" class="headerlink" title="pip改用阿里云镜像源"></a>pip改用阿里云镜像源</h3><p>vim ~/.pip/pip.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">trusted-host =  mirrors.aliyun.com</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure><h3 id="直接使用命令安装"><a href="#直接使用命令安装" class="headerlink" title="直接使用命令安装"></a>直接使用命令安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --trusted-host mirrors.aliyun.com -i http://mirrors.aliyun.com/pypi/simple -r requirements.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;
    
    </summary>
    
      <category term="mirror" scheme="http://blog.rcant.com/categories/mirror/"/>
    
    
      <category term="mirror" scheme="http://blog.rcant.com/tags/mirror/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="http://blog.rcant.com/2019/08/03/algorithm/dynamicprogram-algorithm/"/>
    <id>http://blog.rcant.com/2019/08/03/algorithm/dynamicprogram-algorithm/</id>
    <published>2019-08-03T06:50:07.000Z</published>
    <updated>2020-08-07T02:31:56.875Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><a id="more"></a><h2 id="算法基本思想-理念"><a href="#算法基本思想-理念" class="headerlink" title="算法基本思想 理念"></a>算法基本思想 理念</h2><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，<font color="blue">适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的</font>。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够<font color="red">保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</font>。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。</p><p>具体的动态规划算法多种多样，但它们<font color="red">具有相同的填表格式</font>。</p><p>与<font color="red">分治法最大的差别</font>是：适合于用动态规划法求解的问题，经分解后得到的<font color="blue">子问题往往不是互相独立的</font>（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）</p><h2 id="动态规划分类"><a href="#动态规划分类" class="headerlink" title="动态规划分类"></a>动态规划分类</h2><p>动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。</p><h3 id="线性动规："><a href="#线性动规：" class="headerlink" title="线性动规："></a>线性动规：</h3><blockquote><ol><li>拦截导弹</li><li>合唱队形</li><li>挖地雷</li><li>建学校</li><li>剑客决斗等</li></ol></blockquote><h3 id="区域动规："><a href="#区域动规：" class="headerlink" title="区域动规："></a>区域动规：</h3><blockquote><ol><li>石子合并</li><li>加分二叉树</li><li>统计单词个数</li><li>炮兵布阵等</li></ol></blockquote><h3 id="树形动规："><a href="#树形动规：" class="headerlink" title="树形动规："></a>树形动规：</h3><blockquote><ol><li>贪吃的九头龙</li><li>二分查找树</li><li>聚会的欢乐</li><li>数字三角形等</li></ol></blockquote><h3 id="背包问题："><a href="#背包问题：" class="headerlink" title="背包问题："></a>背包问题：</h3><blockquote><ol><li>01背包问题</li><li>完全背包问题</li><li>分组背包问题</li><li>二维背包</li><li>装箱问题</li><li>挤牛奶等</li></ol></blockquote><h2 id="算法适用条件"><a href="#算法适用条件" class="headerlink" title="算法适用条件"></a>算法适用条件</h2><p>适用条件<br>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性。</p><p>1.<font color="blue">最优化原理</font>（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p><p>2.无后效性将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p><p>3.子问题的重叠性 动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。（<font color="blue">该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势</font>）</p><h2 id="算法的一般解题思路"><a href="#算法的一般解题思路" class="headerlink" title="算法的一般解题思路"></a>算法的一般解题思路</h2><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><pre><code>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态                  图1 动态规划决策过程示意图(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</code></pre><p>实际应用中可以按以下几个简化的步骤进行设计：</p><pre><code>（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解</code></pre><h2 id="算法执行逻辑"><a href="#算法执行逻辑" class="headerlink" title="算法执行逻辑"></a>算法执行逻辑</h2><h2 id="算法例子"><a href="#算法例子" class="headerlink" title="算法例子"></a>算法例子</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>默认递归实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def Fibonacci(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 1</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return Fibonacci(n-1) + Fibonacci(n-2)</span><br></pre></td></tr></table></figure><p>使用动态递归实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def Fibonacci(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 1</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        result = &#123;0:1,1:1&#125;</span><br><span class="line">        for i in range(n-1):</span><br><span class="line">            result[i+2] = result[i+1] + result[i];</span><br><span class="line">        return result[n]</span><br></pre></td></tr></table></figure><p>使用了一个dict 存取每个状态<br>也可以只存上一个状态减少内存消耗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def Fibonacci(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 1</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        pred = 1</span><br><span class="line">        curr = 1</span><br><span class="line">        for i in range(n-1):</span><br><span class="line">            pred,curr = curr,pred+curr</span><br><span class="line">        return curr</span><br></pre></td></tr></table></figure><p>### </p><p><a href="https://blog.csdn.net/zw6161080123/article/details/80639932" target="_blank" rel="noopener">https://blog.csdn.net/zw6161080123/article/details/80639932</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。&lt;br&gt;动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://blog.rcant.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://blog.rcant.com/tags/algorithm/"/>
    
      <category term="算法" scheme="http://blog.rcant.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dynamic program" scheme="http://blog.rcant.com/tags/dynamic-program/"/>
    
      <category term="动态规划" scheme="http://blog.rcant.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法目录</title>
    <link href="http://blog.rcant.com/2019/08/03/algorithm/algorithm-readme/"/>
    <id>http://blog.rcant.com/2019/08/03/algorithm/algorithm-readme/</id>
    <published>2019-08-03T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.874Z</updated>
    
    <content type="html"><![CDATA[<p>算法目录</p><a id="more"></a><h2 id="算法分支"><a href="#算法分支" class="headerlink" title="算法分支"></a>算法分支</h2><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、<a href="/2019/08/03/algorithm/divideconquer-algorithm/" title="分治算法">分治算法</a></h3><blockquote><p>可以将一个大问题分解成若干个小问题解决的问题</p></blockquote><h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、<a href="/2019/08/03/algorithm/dynamicprogram-algorithm/" title="动态规划算法">动态规划算法</a></h3><blockquote><p>根据子问题求解原问题的解（子问题不独立）</p></blockquote><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>　　关键词：局部最优（较好的近似最优解，贪心）、简单、根据当前信息最选择，且不改变、</p><p>　　使用环境：<br>　　1.最优子结构。一个问题的最优解包含了其子问题的最优解。<br>　　2.贪心选择性质。问题的整体最优解可以通过一系列局部最优的选择（贪心选择）来得到</p><p>　　示例：活动选择问题、背包问题、多机调度问题</p><ul><li><p>回溯法</p><p> 关键词：通用的解题法、解空间树（深度优先遍历）、界限函数、所有解（找出满足条件的所有解）</p></li></ul><p>　　步骤：</p><p>　　1.针对所给问题，定义问题的解空间。问题的解空间应至少包含问题的一个（最优）解</p><p>　　2.确定易于搜索的解空间结构。通常将解空间表示为树、图；解空间树的第i层到第i+1层边上的标号给出了变量的值；从树根到叶子的任一路径表示解空间的一个元素。</p><p>　　3.以深度优先的方式搜索整个解空间。如果当前宽展节点处为死节点，则回溯至最近的一个活节点处。（以此方式递归搜索）</p><p>　　算法框架：非递归、递归</p><p>　　界限函数：回溯法的核心。尽可能多、尽可能早地“杀掉”不可能产生最优解的活节点。好的界限函数可以大大减少问题的搜索空间，大大提高算法的效率。</p><p>　　示例：0-1背包、N皇后问题</p><ul><li>分支界限法</li></ul><p>　　关键字：解空间（广度优先、最小耗费优先）、界限函数（队列式、优先队列式）</p><p>　　步骤：</p><p>　　1.针对所给问题，定义问题的解空间。问题的解空间应至少包含问题的一个（最优）解</p><p>　　2.确定易于搜索的解空间结构。通常将解空间表示为树、图；解空间树的第i层到第i+1层边上的标号给出了变量的值；从树根到叶子的任一路径表示解空间的一个元素。</p><p>　　3.以广度优先或最小耗费优先的方式搜索整个解空间。每个活节点只有一次机会成为扩展节点，活节点一旦成为扩展节点，其余儿子节点被加入活节点表中。（以此方式递归搜索）</p><p>　　界限函数：分支界限法的核心。尽可能多、尽可能早地“杀掉”不可能产生最优解的活节点。好的界限函数可以大大减少问题的搜索空间，大大提高算法的效率。</p><p>　　1.队列式（FIFO）分支界限法。先进先出</p><p>　　2.优先队列式分支界限法。组织一个优先队列，按优先级选取。通常用最大堆来实现最大优先队列，最小堆来实现最小优先队列。</p><ul><li>概率算法</li></ul><p>　　关键词：随机性选择、小概率错误（运行时间大幅减少）、不同解（对同一问题求解两次，可能得到完全不同的解，且所需时间、结果可能会有相当大的差别）</p><p>　　基本特征：</p><p>　　1.输入包括两部分。一，原问题的输入；二，供算法进行随机选择的随机数序列<br>　　2.运行过程中，包括一处或多处随机选择，根据随机值来决定算法的运行<br>　　3.结果不能保证一定是正确的，但可以限制出错率。<br>　　4.不同的运行过程中，对于相同的输入实例可以有不同的结果，执行时间也可能不同。</p><p>　　分类：<br>　　1.数值概率算法。常用于数值问题的求解。近似解，近似解的精度随计算时间的增加不断提高。</p><p>　　2.蒙特卡罗（Monte Carlo）算法。精确解，解未必是正确的，正确的概率依赖于算法所用的时间。一般情况下，无法有效地判定所得到的解是否肯定正确。</p><p>　　3.拉斯维加斯（LasVegas）算法。一旦找到解，一定是正确解。找到的概率随计算时间的增加而提高。对实例求解足够多次，使求解失效的概率任意小。</p><p>　　4.舍伍德（Sherwood）算法。总能求得问题的一个解，且所求得的解总是正确的。设法消除最坏情形与特定实例之间的关联性。多用于最快情况下的计算复杂度与其在平均情况下的计算复杂度差别较大。</p><ul><li>近似算法<br>　　关键词：近似解、解的容错界限（近似最优解与最优解之间相差的程度）、不存在多项式时间算法</li></ul><p>　　基本思想：放弃求最优解，用近似最优解替代最优解。使算法简化，时间复杂度降低</p><p>　　衡量性能的标准：</p><p>　　1.算法的时间复杂度。时间复杂度必须是多项式阶的<br>　　2.解的近似程度。与近似算法本身、问题规模、不同的输入实例有关。</p><p>　　示例：NP问题、定点覆盖问题、TSP、子集和数问题、</p><ul><li><p>遗传算法(进化算法)</p></li><li><p>鸟群觅食算法（粒子群算法）</p></li><li><p>A* 算法</p></li></ul><h2 id="算法备注"><a href="#算法备注" class="headerlink" title="算法备注"></a>算法备注</h2><ul><li><p>各种算法分支的理念，最好有流程图</p></li><li><p>每种算法给出例子，源码实现</p></li><li><p>复杂的算法给出框架介绍</p></li><li><p>算法的适应情况</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法目录&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://blog.rcant.com/categories/algorithm/"/>
    
    
      <category term="genetic" scheme="http://blog.rcant.com/tags/genetic/"/>
    
      <category term="algorithm" scheme="http://blog.rcant.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>分治算法</title>
    <link href="http://blog.rcant.com/2019/08/03/algorithm/divideconquer-algorithm/"/>
    <id>http://blog.rcant.com/2019/08/03/algorithm/divideconquer-algorithm/</id>
    <published>2019-08-03T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.875Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，分治法是一种很重要的算法。<br>字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。<br>这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)。</p><a id="more"></a><h2 id="算法基本思想-理念"><a href="#算法基本思想-理念" class="headerlink" title="算法基本思想 理念"></a>算法基本思想 理念</h2><p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>适用的情况：</p><blockquote><ol><li>该问题的规模缩小到一定的程度就可以容易地解决</li><li>该问题可以分解为若干个规模较小的相同问题。</li><li>利用该问题分解出的子问题的解可以合并为该问题的解；</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li></ol></blockquote><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p><p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p><p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p><p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p><h2 id="算法执行逻辑"><a href="#算法执行逻辑" class="headerlink" title="算法执行逻辑"></a>算法执行逻辑</h2><blockquote><ol><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。3. 合并：将各个子问题的解合并为原问题的解。</li></ol></blockquote><p>流程图</p><div id="flowchart-0" class="flow-chart"></div>伪代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Divide-and-Conquer(P):</span><br><span class="line">    if |P|≤n0:</span><br><span class="line">        return ADHOC(P)</span><br><span class="line">    </span><br><span class="line">    for i←1 to k</span><br><span class="line">        yi ← Divide-and-Conquer(Pi)</span><br><span class="line">    </span><br><span class="line">    T ← MERGE(y1,y2,...,yk) </span><br><span class="line">    return(T)</span><br><span class="line"></span><br><span class="line">ADHOC(P):</span><br><span class="line">    return f(P)</span><br></pre></td></tr></table></figure><p>注：</p><blockquote><ol><li>其中|P|表示问题P的规模</li><li>n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。</li><li>ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。</li><li>算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解</li></ol></blockquote><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(n)= k*T(n/m)+f(n)</span><br></pre></td></tr></table></figure><h2 id="分治法解题例子-TODO-需要扩展"><a href="#分治法解题例子-TODO-需要扩展" class="headerlink" title="分治法解题例子 TODO 需要扩展"></a>分治法解题例子 TODO 需要扩展</h2><p>（1）二分搜索<br>（2）大整数乘法<br>（3）Strassen矩阵乘法<br>（4）棋盘覆盖<br>（5）合并排序<br>（6）快速排序<br>（7）线性时间选择<br>（8）最接近点对问题<br>（9）循环赛日程表<br>（10）汉诺塔</p><h2 id="算法备注"><a href="#算法备注" class="headerlink" title="算法备注"></a>算法备注</h2><p>依据分治法设计程序时的思维过程<br>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p><blockquote><p>1、一定是先找到最小问题规模时的求解方法<br>2、然后考虑随着问题规模增大时的求解方法<br>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</p></blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始求问题Pe=>end: 结束返回P的解op=>operation: 求问题规模P|pastcond=>condition: P最小规模n0?minP=>operation: ADHOC(P)op2=>operation: 问题P分解为P1,P2..Pkop4=>operation: 求问题Pi合并问题P1,P2..Pk的解st->op->condcond(yes)->minPcond(no)->op2op2->op4op4(left)->opminP->eop4->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，分治法是一种很重要的算法。&lt;br&gt;字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。&lt;br&gt;这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://blog.rcant.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://blog.rcant.com/tags/algorithm/"/>
    
      <category term="divide conquer" scheme="http://blog.rcant.com/tags/divide-conquer/"/>
    
      <category term="分治" scheme="http://blog.rcant.com/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="算法" scheme="http://blog.rcant.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Genetic Algorithm 使用</title>
    <link href="http://blog.rcant.com/2019/08/01/algorithm/genetic-algorithm-use/"/>
    <id>http://blog.rcant.com/2019/08/01/algorithm/genetic-algorithm-use/</id>
    <published>2019-08-01T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.876Z</updated>
    
    <content type="html"><![CDATA[<p>遗传算法</p><a id="more"></a><h2 id="1-什么是遗传算法"><a href="#1-什么是遗传算法" class="headerlink" title="1. 什么是遗传算法"></a>1. 什么是遗传算法</h2><p>是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p><p>是一类借鉴生物界的进化规律（适者生存，优胜劣汰遗传机制）演化而来的随机化搜索方法。</p><h2 id="2-遗传算法基本运算过程"><a href="#2-遗传算法基本运算过程" class="headerlink" title="2. 遗传算法基本运算过程"></a>2. 遗传算法基本运算过程</h2><h3 id="a-初始化：设置进化代数计数器t-0，设置最大进化代数T，随机生成M个个体作为初始群体P-0-。"><a href="#a-初始化：设置进化代数计数器t-0，设置最大进化代数T，随机生成M个个体作为初始群体P-0-。" class="headerlink" title="a)初始化：设置进化代数计数器t=0，设置最大进化代数T，随机生成M个个体作为初始群体P(0)。"></a>a)初始化：设置进化代数计数器t=0，设置最大进化代数T，随机生成M个个体作为初始群体P(0)。</h3><h3 id="b-个体评价：计算群体P-t-中各个个体的适应度。"><a href="#b-个体评价：计算群体P-t-中各个个体的适应度。" class="headerlink" title="b)个体评价：计算群体P(t)中各个个体的适应度。"></a>b)个体评价：计算群体P(t)中各个个体的适应度。</h3><h3 id="c-选择运算：将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。"><a href="#c-选择运算：将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。" class="headerlink" title="c)选择运算：将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。"></a>c)选择运算：将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。</h3><h3 id="d-交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。"><a href="#d-交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。" class="headerlink" title="d)交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。"></a>d)交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。</h3><h3 id="e-变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。群体P-t-经过选择、交叉、变异运算之后得到下一代群体P-t-1-。"><a href="#e-变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。群体P-t-经过选择、交叉、变异运算之后得到下一代群体P-t-1-。" class="headerlink" title="e)变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。群体P(t)经过选择、交叉、变异运算之后得到下一代群体P(t+1)。"></a>e)变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。群体P(t)经过选择、交叉、变异运算之后得到下一代群体P(t+1)。</h3><h3 id="f-终止条件判断：若t-T-则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。"><a href="#f-终止条件判断：若t-T-则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。" class="headerlink" title="f)终止条件判断：若t=T,则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。"></a>f)终止条件判断：若t=T,则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。</h3><h2 id="3-连接ADB客户端"><a href="#3-连接ADB客户端" class="headerlink" title="3. 连接ADB客户端"></a>3. 连接ADB客户端</h2><h2 id="4-模拟器开启Root权限"><a href="#4-模拟器开启Root权限" class="headerlink" title="4. 模拟器开启Root权限"></a>4. 模拟器开启Root权限</h2><h2 id="5-可能出现的问题"><a href="#5-可能出现的问题" class="headerlink" title="5. 可能出现的问题"></a>5. 可能出现的问题</h2><h2 id="6-使用adb-shell调试"><a href="#6-使用adb-shell调试" class="headerlink" title="6. 使用adb shell调试"></a>6. 使用adb shell调试</h2><h2 id="7-用GDB调试程序，dump内存"><a href="#7-用GDB调试程序，dump内存" class="headerlink" title="7. 用GDB调试程序，dump内存"></a>7. 用GDB调试程序，dump内存</h2><h2 id="8-gdb-dump-破解源码"><a href="#8-gdb-dump-破解源码" class="headerlink" title="8. gdb dump 破解源码"></a>8. gdb dump 破解源码</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遗传算法&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://blog.rcant.com/categories/algorithm/"/>
    
    
      <category term="genetic" scheme="http://blog.rcant.com/tags/genetic/"/>
    
      <category term="algorithm" scheme="http://blog.rcant.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7.x单用户模式更改密码</title>
    <link href="http://blog.rcant.com/2019/04/01/centos/centos-change-rootpasswd/"/>
    <id>http://blog.rcant.com/2019/04/01/centos/centos-change-rootpasswd/</id>
    <published>2019-04-01T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>CentOS7.x单用户模式更改密码 </p><a id="more"></a><p>CentOS7.x单用户模式与之前版本略有不同 <a href="http://blog.csdn.net/u013943420/article/details/71752648#t31" target="_blank" rel="noopener">老版本参考</a></p><h2 id="1-启动系统，并在GRUB2启动屏显时，按下e键进入编辑模式。"><a href="#1-启动系统，并在GRUB2启动屏显时，按下e键进入编辑模式。" class="headerlink" title="1 启动系统，并在GRUB2启动屏显时，按下e键进入编辑模式。"></a>1 启动系统，并在GRUB2启动屏显时，按下e键进入编辑模式。</h2><img src="/2019/04/01/centos/centos-change-rootpasswd/1.png" title="进入编辑模式"><h2 id="2-进入下一个界面后，用方向键找到”linux16”所在的行，在行末加入内容：init-bin-sh-然后按”ctrl-x”-重启。"><a href="#2-进入下一个界面后，用方向键找到”linux16”所在的行，在行末加入内容：init-bin-sh-然后按”ctrl-x”-重启。" class="headerlink" title="2 进入下一个界面后，用方向键找到”linux16”所在的行，在行末加入内容：init=/bin/sh ,然后按”ctrl + x” 重启。"></a>2 进入下一个界面后，用方向键找到”linux16”所在的行，在行末加入内容：init=/bin/sh ,然后按”ctrl + x” 重启。</h2><img src="/2019/04/01/centos/centos-change-rootpasswd/2.png" title="sh启动"><h2 id="3-如果第二步中设置rw为ro则需要进行本步骤设置，否则不需要"><a href="#3-如果第二步中设置rw为ro则需要进行本步骤设置，否则不需要" class="headerlink" title="3 如果第二步中设置rw为ro则需要进行本步骤设置，否则不需要"></a>3 如果第二步中设置rw为ro则需要进行本步骤设置，否则不需要</h2><p>在提示符下输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure><p>挂载文件系统为可写模式，输入的命令有可能不会显示出来，输入完成按回车</p><img src="/2019/04/01/centos/centos-change-rootpasswd/3.png" title="设置挂载文件可写"><h2 id="4-运行passwd-并按提示修改root密码"><a href="#4-运行passwd-并按提示修改root密码" class="headerlink" title="4 运行passwd,并按提示修改root密码"></a>4 运行passwd,并按提示修改root密码</h2><h2 id="5-运行命令“touch-autorelabel”，否则将无法正常启动系统（这句是为了selinux生效，据说是selinux在重启后更新label）"><a href="#5-运行命令“touch-autorelabel”，否则将无法正常启动系统（这句是为了selinux生效，据说是selinux在重启后更新label）" class="headerlink" title="5 运行命令“touch / .autorelabel”，否则将无法正常启动系统（这句是为了selinux生效，据说是selinux在重启后更新label）"></a>5 运行命令“touch / .autorelabel”，否则将无法正常启动系统（这句是为了selinux生效，据说是selinux在重启后更新label）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch / .autorelabel</span><br></pre></td></tr></table></figure><h2 id="6-运行命令exec-sbin-init来正常启动，等5-10分钟。"><a href="#6-运行命令exec-sbin-init来正常启动，等5-10分钟。" class="headerlink" title="6 运行命令exec /sbin/init来正常启动，等5-10分钟。"></a>6 运行命令exec /sbin/init来正常启动，等5-10分钟。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec /sbin/init</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;CentOS7.x单用户模式更改密码 &lt;/p&gt;
    
    </summary>
    
      <category term="centos" scheme="http://blog.rcant.com/categories/centos/"/>
    
    
      <category term="centos" scheme="http://blog.rcant.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>python 代码规范和命名规范</title>
    <link href="http://blog.rcant.com/2019/02/13/python/python3-code/"/>
    <id>http://blog.rcant.com/2019/02/13/python/python3-code/</id>
    <published>2019-02-13T08:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>python 代码规范和命名规范</p><a id="more"></a><p>Python代码规范</p><h2 id="一、简明概述"><a href="#一、简明概述" class="headerlink" title="一、简明概述"></a>一、简明概述</h2><h3 id="1、编码"><a href="#1、编码" class="headerlink" title="1、编码"></a>1、编码</h3><blockquote><blockquote><blockquote><p>如无特殊情况, 文件一律使用 UTF-8 编码<br>如无特殊情况, 文件头部必须加入#–coding:utf-8–标识</p></blockquote></blockquote></blockquote><h3 id="2、代码格式"><a href="#2、代码格式" class="headerlink" title="2、代码格式"></a>2、代码格式</h3><h4 id="2-1、缩进"><a href="#2-1、缩进" class="headerlink" title="2.1、缩进"></a>2.1、缩进</h4><p>统一使用 4 个空格进行缩进</p><h4 id="2-2、行宽"><a href="#2-2、行宽" class="headerlink" title="2.2、行宽"></a>2.2、行宽</h4><p>每行代码尽量不超过 80 个字符(在特殊情况下可以略微超过 80 ，但最长不得超过 120)<br>理由：<br>这在查看 side-by-side 的 diff 时很有帮助<br>方便在控制台下查看代码<br>太长可能是设计有缺陷</p><h4 id="2-3、引号"><a href="#2-3、引号" class="headerlink" title="2.3、引号"></a>2.3、引号</h4><p>简单说，自然语言使用双引号，机器标示使用单引号，因此 代码里 多数应该使用 单引号<br>自然语言 使用双引号 “…”<br>例如错误信息；很多情况还是 unicode，使用u”你好世界”<br>机器标识 使用单引号 ‘…’<br>例如 dict 里的 key<br>正则表达式 使用原生的双引号 r”…”<br>文档字符串 (docstring) 使用三个双引号 “””……”””</p><h4 id="2-4、空行"><a href="#2-4、空行" class="headerlink" title="2.4、空行"></a>2.4、空行</h4><p>模块级函数和类定义之间空两行；<br>类成员函数之间空一行；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def hello(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>可以使用多个空行分隔多组相关的函数<br>函数中可以使用空行分隔出逻辑相关的代码</p><h4 id="2-5、编码"><a href="#2-5、编码" class="headerlink" title="2.5、编码"></a>2.5、编码</h4><blockquote><p>文件使用 UTF-8 编码<br>文件头部加入#-<em>-conding:utf-8-</em>-标识</p></blockquote><h3 id="3、import-语句"><a href="#3、import-语句" class="headerlink" title="3、import 语句"></a>3、import 语句</h3><p>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys,os</span><br></pre></td></tr></table></figure><p>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from subprocess import Popen, PIPE</span><br></pre></td></tr></table></figure><p>import语句应该使用 absolute import</p><p>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from foo.bar import Bar</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from ..bar import Bar</span><br></pre></td></tr></table></figure><p>import语句应该放在文件头部，置于模块说明及docstring之后，于全局变量之前；<br>import语句应该按照顺序排列，每组之间用一个空行分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import msgpack</span><br><span class="line">import zmq</span><br><span class="line"></span><br><span class="line">import foo</span><br></pre></td></tr></table></figure><p>导入其他模块的类定义时，可以使用相对导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from myclass import MyClass</span><br></pre></td></tr></table></figure><p>如果发生命名冲突，则可使用命名空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import bar</span><br><span class="line">import foo.bar</span><br><span class="line"></span><br><span class="line">bar.Bar()</span><br><span class="line">foo.bar.Bar()</span><br></pre></td></tr></table></figure><h3 id="4、空格"><a href="#4、空格" class="headerlink" title="4、空格"></a>4、空格</h3><p>在二元运算符两边各空一格[=,-,+=,==,&gt;,in,is not, and]:<br>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1</span><br><span class="line">submitted += 1</span><br><span class="line">x = x * 2 - 1</span><br><span class="line">hypot2 = x * x + y * y</span><br><span class="line">c = (a + b) * (a - b)</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=i+1</span><br><span class="line">submitted +=1</span><br><span class="line">x = x*2 - 1</span><br><span class="line">hypot2 = x*x + y*y</span><br><span class="line">c = (a+b) * (a-b)</span><br></pre></td></tr></table></figure><p>函数的参数列表中，,之后要有空格<br>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def complex(real, imag):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p> 不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def complex(real,imag):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>函数的参数列表中，默认值等号两边不要添加空格<br> 正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def complex(real, imag=0.0):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p> 不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def complex(real, imag = 0.0):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>左括号之后，右括号之前不要加多余的空格<br> 正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam(ham[1], &#123;eggs: 2&#125;)</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam( ham[1], &#123; eggs : 2 &#125; )</span><br></pre></td></tr></table></figure><p>字典对象的左括号之前不要多余的空格<br>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict[&apos;key&apos;] = list[index]</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict [&apos;key&apos;] = list [index]</span><br></pre></td></tr></table></figure><p>不要为对齐赋值语句而使用的额外空格<br>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">long_variable = 3</span><br></pre></td></tr></table></figure><p> 不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x             = 1</span><br><span class="line">y             = 2</span><br><span class="line">long_variable = 3</span><br></pre></td></tr></table></figure><h3 id="5、换行"><a href="#5、换行" class="headerlink" title="5、换行"></a>5、换行</h3><p>Python 支持括号内的换行。这时有两种情况。<br>1) 第二行缩进到括号的起始处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br></pre></td></tr></table></figure><p>2) 第二行缩进 4 个空格，适用于起始括号就换行的情形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def long_function_name(</span><br><span class="line">        var_one, var_two, var_three,</span><br><span class="line">        var_four):</span><br><span class="line">    print(var_one)</span><br></pre></td></tr></table></figure><p>使用反斜杠\换行，二元运算符+ .等应出现在行末；长字符串也可以用此法换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">session.query(MyTable).\</span><br><span class="line">        filter_by(id=1).\</span><br><span class="line">        one()</span><br><span class="line"></span><br><span class="line">print &apos;Hello, &apos;\</span><br><span class="line">      &apos;%s %s!&apos; %\</span><br><span class="line">      (&apos;Harry&apos;, &apos;Potter&apos;)</span><br></pre></td></tr></table></figure><p>禁止复合语句，即一行中包含多个语句：<br>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do_first()</span><br><span class="line">do_second()</span><br><span class="line">do_third()</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_first();do_second();do_third();</span><br></pre></td></tr></table></figure><p>if/for/while一定要换行：<br>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if foo == &apos;blah&apos;:</span><br><span class="line">    do_blah_thing()</span><br></pre></td></tr></table></figure><p>不推荐的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if foo == &apos;blah&apos;: do_blash_thing()</span><br></pre></td></tr></table></figure><h3 id="6、docstring"><a href="#6、docstring" class="headerlink" title="6、docstring"></a>6、docstring</h3><p>docstring 的规范中最其本的两点：<br>所有的公共模块、函数、类、方法，都应该写 docstring 。私有方法不一定需要，但应该在 def 后提供一个块注释来说明。<br>docstring 的结束”””应该独占一行，除非此 docstring 只有一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;Return a foobar</span><br><span class="line">Optional plotz says to frobnicate the bizbaz first.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;Oneline docstring&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h2><h3 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h3><h4 id="1-1、块注释"><a href="#1-1、块注释" class="headerlink" title="1.1、块注释"></a>1.1、块注释</h4><p>“#”号后空一格，段落件用空行分开（同样需要“#”号）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 块注释</span><br><span class="line"># 块注释</span><br><span class="line">#</span><br><span class="line"># 块注释</span><br><span class="line"># 块注释</span><br></pre></td></tr></table></figure><h4 id="1-2、行注释"><a href="#1-2、行注释" class="headerlink" title="1.2、行注释"></a>1.2、行注释</h4><p>至少使用两个空格和语句分开，注意不要使用无意义的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">x = x + 1  # 边框加粗一个像素</span><br><span class="line"></span><br><span class="line"># 不推荐的写法(无意义的注释)</span><br><span class="line">x = x + 1 # x加1</span><br></pre></td></tr></table></figure><h4 id="1-3、建议"><a href="#1-3、建议" class="headerlink" title="1.3、建议"></a>1.3、建议</h4><p>在代码的关键部分(或比较复杂的地方), 能写注释的要尽量写注释<br>比较重要的注释段, 使用多个等号隔开, 可以更加醒目, 突出重要性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app = create_app(name, options)</span><br><span class="line"></span><br><span class="line"># =====================================</span><br><span class="line"># 请勿在此处添加 get post等app路由行为 !!!</span><br><span class="line"># =====================================</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h3 id="2、文档注释（Docstring）"><a href="#2、文档注释（Docstring）" class="headerlink" title="2、文档注释（Docstring）"></a>2、文档注释（Docstring）</h3><p>作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的<strong>doc</strong>对象获取文档.<br>编辑器和IDE也可以根据Docstring给出自动提示.<br>文档注释以 “”” 开头和结尾, 首行不换行, 如有多行, 末行必需换行, 以下是Google的docstring风格示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;Example docstrings.</span><br><span class="line"></span><br><span class="line">This module demonstrates documentation as specified by the `Google Python</span><br><span class="line">Style Guide`_. Docstrings may extend over multiple lines. Sections are created</span><br><span class="line">with a section header and a colon followed by a block of indented text.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">    Examples can be given using either the ``Example`` or ``Examples``</span><br><span class="line">    sections. Sections support any reStructuredText formatting, including</span><br><span class="line">    literal blocks::</span><br><span class="line"></span><br><span class="line">        $ python example_google.py</span><br><span class="line"></span><br><span class="line">Section breaks are created by resuming unindented text. Section breaks</span><br><span class="line">are also implicitly created anytime a new section starts.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>不要在文档注释复制函数定义原型, 而是具体描述其具体内容, 解释具体参数和返回值等</p><ul><li><p>不推荐的写法(不要写函数原型等废话)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def function(a, b):</span><br><span class="line">    &quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot;</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure></li><li><p>正确的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def function(a, b):</span><br><span class="line">    &quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot;</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure></li></ul><p>对函数参数、返回值等的说明采用numpy标准, 如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def func(arg1, arg2):</span><br><span class="line">    &quot;&quot;&quot;在这里写函数的一句话总结(如: 计算平均值).</span><br><span class="line"></span><br><span class="line">    这里是具体描述.</span><br><span class="line"></span><br><span class="line">    参数</span><br><span class="line">    ----------</span><br><span class="line">    arg1 : int</span><br><span class="line">        arg1的具体描述</span><br><span class="line">    arg2 : int</span><br><span class="line">        arg2的具体描述</span><br><span class="line"></span><br><span class="line">    返回值</span><br><span class="line">    -------</span><br><span class="line">    int</span><br><span class="line">        返回值的具体描述</span><br><span class="line"></span><br><span class="line">    参看</span><br><span class="line">    --------</span><br><span class="line">    otherfunc : 其它关联函数等...</span><br><span class="line"></span><br><span class="line">    示例</span><br><span class="line">    --------</span><br><span class="line">    示例使用doctest格式, 在`&gt;&gt;&gt;`后的代码可以被文档测试工具作为测试用例自动运行</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; a=[1,2,3]</span><br><span class="line">    &gt;&gt;&gt; print [x + 3 for x in a]</span><br><span class="line">    [4, 5, 6]</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>文档注释不限于中英文, 但不要中英文混用<br>文档注释不是越长越好, 通常一两句话能把情况说清楚即可<br>模块、公有类、公有方法, 能写文档注释的, 应该尽量写文档注释</p><h2 id="三、命名规范"><a href="#三、命名规范" class="headerlink" title="三、命名规范"></a>三、命名规范</h2><h3 id="1、模块"><a href="#1、模块" class="headerlink" title="1、模块"></a>1、模块</h3><p>模块尽量使用小写命名，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况)</p><ul><li><p>正确的模块名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import decoder</span><br><span class="line">import html_parser</span><br></pre></td></tr></table></figure></li><li><p>不推荐的模块名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Decoder</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、类名"><a href="#2、类名" class="headerlink" title="2、类名"></a>2、类名</h3><p>类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Farm():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class AnimalFarm(Farm):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class _PrivateFarm(Farm):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</p><h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><p>函数名一律小写，如有多个单词，用下划线隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def run():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def run_with_env():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>私有函数在函数前加一个下划线_</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person():</span><br><span class="line"></span><br><span class="line">    def _private_func():</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><h3 id="4、变量名"><a href="#4、变量名" class="headerlink" title="4、变量名"></a>4、变量名</h3><p>变量名尽量小写, 如有多个单词，用下划线隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    count = 0</span><br><span class="line">    school_name = &apos;&apos;</span><br></pre></td></tr></table></figure><p>常量采用全大写，如有多个单词，使用下划线隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_CLIENT = 100</span><br><span class="line">MAX_CONNECTION = 1000</span><br><span class="line">CONNECTION_TIMEOUT = 600</span><br></pre></td></tr></table></figure><h3 id="5、常量"><a href="#5、常量" class="headerlink" title="5、常量"></a>5、常量</h3><p>常量使用以下划线分隔的大写命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAX_OVERFLOW = 100</span><br><span class="line"></span><br><span class="line">Class FooBar:</span><br><span class="line"></span><br><span class="line">    def foo_bar(self, print_):</span><br><span class="line">        print(print_)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 代码规范和命名规范&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.rcant.com/categories/python/"/>
    
    
      <category term="python" scheme="http://blog.rcant.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 字符串处理</title>
    <link href="http://blog.rcant.com/2019/02/13/python/python3-string/"/>
    <id>http://blog.rcant.com/2019/02/13/python/python3-string/</id>
    <published>2019-02-13T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.908Z</updated>
    
    <content type="html"><![CDATA[<p>python 字符串处理</p><a id="more"></a><h4 id="1-切片操作"><a href="#1-切片操作" class="headerlink" title="1. 切片操作"></a>1. 切片操作</h4><p>Python访问自字符串可以| 进行切片操作 .|下面举一个栗子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str1=&apos;string&apos;</span><br><span class="line">&gt;&gt;&gt; str1[1:2]</span><br><span class="line">&apos;t&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; str1=&apos;字符串好&apos;</span><br><span class="line">&gt;&gt;&gt; str[:3]</span><br><span class="line">&gt;&gt;&gt; str1[:3]</span><br><span class="line">&apos;字符串&apos;</span><br></pre></td></tr></table></figure><h4 id="2-字符串格式化"><a href="#2-字符串格式化" class="headerlink" title="2. 字符串格式化"></a>2. 字符串格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str1=&apos;字符串&apos;</span><br><span class="line">&gt;&gt;&gt; print(&apos;我是%s&apos; %str1)</span><br><span class="line">我是字符串</span><br></pre></td></tr></table></figure><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整型</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号十六进制数</td></tr><tr><td>%X</td><td>格式化无符号十六进制数（大写）</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>作用同%e，用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%f 和 %E 的简写</td></tr><tr><td>%p</td><td>用十六进制数格式化变量的地址</td></tr></tbody></table><h4 id="字符串内建函数"><a href="#字符串内建函数" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h4><p>字符串方法是从Python1.6到2.0慢慢加进来的<br>这些方法实现了string模块的大部分方法 , 如下表硕士列出了目前字符串内建支持的方法 .</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.count(str, beg=0, end=len(string))</td><td>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>string.decode(encoding=’UTF-8’, errors=’strict’)</td><td>以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td>string.encode(encoding=’UTF-8’, errors=’strict’)</td><td>以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td>string.endswith(obj, beg=0, end=len(string))</td><td>检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td>string.expandtabs(tabsize=8)</td><td>把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td></tr><tr><td>string.find(str, beg=0, end=len(string))</td><td>检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td>string.index(str, beg=0, end=len(string))</td><td>跟find()方法一样，只不过如果str不在 string中会报一个异常.</td></tr><tr><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td></tr><tr><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td></tr><tr><td>string.isdecimal()</td><td>如果 string 只包含十进制数字则返回 True 否则返回 False.</td></tr><tr><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True 否则返回 False.</td></tr><tr><td>string.islower()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td>string.isnumeric()</td><td>如果 string 中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True，否则返回 False.</td></tr><tr><td>string.istitle()</td><td>如果 string 是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td>string.isupper()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.lower()</td><td>转换 string 中所有大写字符为小写.</td></tr><tr><td>string.lstrip()</td><td>截掉 string 左边的空格</td></tr><tr><td>string.maketrans(intab, outtab])</td><td>maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td>max(str)</td><td>返回字符串 str 中最大的字母。</td></tr><tr><td>min(str)</td><td>返回字符串 str 中最小的字母。</td></tr><tr><td>string.partition(str)</td><td>有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</td></tr><tr><td>string.replace(str1, str2,num=string.count(str1))</td><td>把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td></tr><tr><td>string.rfind(str, beg=0,end=len(string) )</td><td>类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td>string.rindex( str, beg=0,end=len(string))</td><td>类似于 index()，不过是从右边开始.</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.rpartition(str)</td><td>类似于 partition()函数,不过是从右边开始查找.</td></tr><tr><td>string.rstrip()</td><td>删除 string 字符串末尾的空格.</td></tr><tr><td>string.split(str=””, num=string.count(str))</td><td>以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串</td></tr><tr><td>string.splitlines(num=string.count(‘\n’))</td><td>按照行分隔，返回一个包含各行作为元素的列表，如果 num 指定则仅切片 num 个行.</td></tr><tr><td>string.startswith(obj, beg=0,end=len(string))</td><td>检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td></tr><tr><td>string.strip([obj])</td><td>在 string 上执行 lstrip()和 rstrip()</td></tr><tr><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr><tr><td>string.title()</td><td>返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td>string.translate(str, del=””)</td><td>根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td></tr><tr><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr><td>string.zfill(width)</td><td>返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td></tr><tr><td>string.isdecimal()</td><td>isdecimal()方法检查字符串是否只包含十进制字符。这种方法只存在于unicode对象。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 字符串处理&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.rcant.com/categories/python/"/>
    
    
      <category term="python" scheme="http://blog.rcant.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 代码和命令规范(Unity)</title>
    <link href="http://blog.rcant.com/2019/01/05/csharp/csharp-code-rule/"/>
    <id>http://blog.rcant.com/2019/01/05/csharp/csharp-code-rule/</id>
    <published>2019-01-05T03:39:17.000Z</published>
    <updated>2020-08-07T02:31:56.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><a id="more"></a><h2 id="1-规范目的："><a href="#1-规范目的：" class="headerlink" title="1.规范目的："></a>1.规范目的：</h2><ul><li>（1.1）增强代码可维护性。代码的编写不是一次性就能写得很完美的，需要不断的修复bug，修改或增加功能，重新设计整体架构等。这时就需要进入代码中去做修改，如果没有良好的代码规范，时间久了自己阅读起来就很费力。 </li><li>（1.2）提高团队开发效率。大多数项目的代码都不是由一个人编写的，其他成员也许会因为项目的交接需要接手管理你所编写的代码，如果没有良好的代码规范，他人便无法快速轻松的理解你的代码。 </li><li>（1.3）提高个人编码效率。最开始可能会觉得被规范约束，后来反而会因为有规范而有依靠感，不必再为起什么名字而犹豫。</li></ul><h2 id="2-规范说明："><a href="#2-规范说明：" class="headerlink" title="2.规范说明："></a>2.规范说明：</h2><blockquote><p>代码的规范不是绝对的，每个公司都会有自己的一套代码规范，每个新人刚进入都要最先学习代码规范，才能加入到团队的开发中来。</p></blockquote><h2 id="3-命名规范："><a href="#3-命名规范：" class="headerlink" title="3.命名规范："></a>3.命名规范：</h2><h3 id="（3-1）基本规则（对于类、字段、方法、参数、变量）："><a href="#（3-1）基本规则（对于类、字段、方法、参数、变量）：" class="headerlink" title="（3.1）基本规则（对于类、字段、方法、参数、变量）："></a>（3.1）基本规则（对于类、字段、方法、参数、变量）：</h3><ul><li>【规则1-1】英文单词命名。禁止使用拼音或无意义的字母命名。 </li><li>【规则1-2】直观易懂。使用能够描述其功能或意义的英文单词或词组。 </li><li>【规则1-3】除了常量的命名以外，不要采用下划线命名法。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名表示 汽车类型 的字段：</span></span><br><span class="line"><span class="keyword">int</span> carType <span class="comment">//正确：英文词组、能描述其意义。</span></span><br><span class="line"><span class="keyword">int</span> qicheleixing <span class="comment">//错误：拼音。</span></span><br><span class="line"><span class="keyword">int</span> akhj <span class="comment">//错误：无意义。</span></span><br><span class="line"><span class="keyword">int</span> car <span class="comment">//错误：不能描述其意义。</span></span><br><span class="line"><span class="keyword">int</span> car_type <span class="comment">//错误：下划线命名。</span></span><br></pre></td></tr></table></figure><ul><li><p>【规则1-4】约定俗成的变量可以 依次 简单命名。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名循环里的递增（减）变量：</span></span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br></pre></td></tr></table></figure></li><li><p>【规则1-5】命名空间名、类名、接口名、非私有字段名、枚举名及枚举值名、方法名采用 大驼峰式命名法 ，即每一个单词的首字母都大写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Car</span> &#123;&#125; <span class="comment">//命名空间名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SendManager</span>; <span class="comment">//类名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IState</span>; <span class="comment">//接口名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> FirstName; <span class="comment">//非私有字段名</span></span><br><span class="line"><span class="keyword">enum</span> CarDriveType &#123;FrontWheelDrive, RearWheelDrive, FourWheelDrive&#125;<span class="comment">//枚举名及枚举值名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="keyword">string</span> message</span>) </span>&#123;&#125; <span class="comment">//方法名</span></span><br></pre></td></tr></table></figure></li><li><p>【规则1-6】私有字段名、方法参数名、局部变量名采用 小驼峰式命名法 ，即第一个单词首字母小写，其余单词首字母大写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mFirstName; <span class="comment">//私有字段名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindByFirstName</span>(<span class="params"><span class="keyword">string</span> firstName</span>) </span>&#123; <span class="comment">//方法参数名</span></span><br><span class="line">    <span class="keyword">string</span> firstName; <span class="comment">//局部变量名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>###（3.2）特殊规则：</p><ul><li>【规则2-1】接口的命名要以“I”开头。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IState</span>;</span><br></pre></td></tr></table></figure><ul><li>【规则2-2】类的私有变量命名以“m”开头。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mFirstName;</span><br></pre></td></tr></table></figure><ul><li>【规则2-3】常量的命名单词之间用“_”隔开，所有字母均大写。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">float</span> MAX_SPEED = <span class="number">180.0</span>f;</span><br></pre></td></tr></table></figure><ul><li>【规则2-4】若方法返回一个成员变量的值，则方法名一般为Get + 成员变量名。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetFirstName</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>【规则2-5】若方法修改一个成员变量的值，则方法名一般为Set + 成员变量名。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetFirstName</span>(<span class="params"><span class="keyword">string</span> firstName</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【规则2-6】若方法返回的值是bool变量，则方法名一般根据含义以Is/Can/Has/Try作为前缀。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsEmpty</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">CanEmpty</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【规则2-7】避免方法内的局部变量与类的字段命名相同。</p></li></ul><h3 id="4-编码规范："><a href="#4-编码规范：" class="headerlink" title="4.编码规范："></a>4.编码规范：</h3><p>【规则3-1】声明变量时，一行只声明一个变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mFirstName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mLastName;</span><br></pre></td></tr></table></figure><p>【规则3-2】声明变量时，依次简单变量允许一行声明多个。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j,k;</span><br></pre></td></tr></table></figure><p>【规则3-3】局部变量声明时，采用就近原则，即将使用该变量时再声明。<br>【规则3-4】“｛”与“｝”的位置如下所示，均独占一行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Example</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line">    i += j;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    k = k * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【规则3-5】 两个方法之间使用一个空行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExampleA</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExampleB</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【规则3-6】 类的字段声明统一放置于类的最前端，并且最后一个声明与类的第一个方法之间使用一个空行。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> mFirstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> mLastName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetFirstName</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>【规则3-7】方法参数列表中的“，”后面使用一个空格。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span>(<span class="params"><span class="keyword">string</span> firstName, <span class="keyword">string</span> lastName</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【规则3-8】二元操作符，除了“.”在其两边各使用一个空格。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = c + d;</span><br></pre></td></tr></table></figure><p>【规则3-9】for语句表达式子中“；”后面使用一个空格。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【规则3-10】强制转换后面使用一个空格。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">c = (<span class="keyword">char</span>) a;</span><br></pre></td></tr></table></figure><p>【规则3-11】如果if、for、while语句内容只有一行，可以不加“｛｝”，但是必须和if、for、while语句位于同一行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">5</span>) i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>【规则3-12】一行代码长度不要超过屏幕宽度。如果超过了，将超过部分换行。特殊情况下不强求，如定义了海量内容的常量数组（比如所有敏感词）或上下列整齐的公式。</p><p>5.注释规范：<br>【规则4-1】代码头部注释，包含以下内容:<br>文件名称：文件的名称。<br>功能描述：文件的功能描述与大概流程说明。<br>作者：创建并编写的人员。<br>日期：创建并编写的日期。<br>修改记录：若类有所修改，则需要有修改人员的名字、修改日期及修改理由。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名称：UserInput.cs</span></span><br><span class="line"><span class="comment">// 功能描述：玩家输入按键的定义</span></span><br><span class="line"><span class="comment">// 编写作者：张三</span></span><br><span class="line"><span class="comment">// 编写日期：2017.7.16</span></span><br><span class="line"><span class="comment">// 修改记录：</span></span><br><span class="line"><span class="comment">//      R1:</span></span><br><span class="line"><span class="comment">//          修改作者：李四</span></span><br><span class="line"><span class="comment">//          修改日期：2017.7.17</span></span><br><span class="line"><span class="comment">//          修改理由：使玩家可以自定义输入按键</span></span><br><span class="line"></span><br><span class="line">Using System;</span><br></pre></td></tr></table></figure><p>【规则4-2】方法注释，采用 /// 形式自动产生XML标签格式的注释。包括方法功能，参数含义，返回内容。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置场景的名字.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;c&gt;</span>true<span class="doctag">&lt;/c&gt;</span>, 场景名字设置成功, <span class="doctag">&lt;c&gt;</span>false<span class="doctag">&lt;/c&gt;</span> 场景名字设置失败.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="sceneName"&gt;</span>场景名字.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">SetSceneName</span>(<span class="params"><span class="keyword">string</span> sceneName</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【规则4-3】类变量注释，采用 /// 形式自动产生XML标签格式的注释变量含义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 场景的名字</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">private string mSceneName;</span><br></pre></td></tr></table></figure><p>【规则4-4】局部变量注释，在变量声明语句的后面注释，与前后行变量声明的注释左对齐，注释与代码间以Tab隔开。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> firstName;   <span class="comment">//姓</span></span><br><span class="line"><span class="keyword">string</span> lastName;    <span class="comment">//名</span></span><br></pre></td></tr></table></figure><p>【规则4-5】代码行注释，注释位于代码上行，与代码开始处左对齐，双斜线与注释之间以空格分开。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置场景的名字。</span></span><br><span class="line"><span class="keyword">this</span>.mSceneName = sceneName;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;
    
    </summary>
    
      <category term="CSharp" scheme="http://blog.rcant.com/categories/CSharp/"/>
    
    
      <category term="CSharp" scheme="http://blog.rcant.com/tags/CSharp/"/>
    
      <category term="Unity" scheme="http://blog.rcant.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3 使用</title>
    <link href="http://blog.rcant.com/2018/12/29/sublime/sublime-text3-used/"/>
    <id>http://blog.rcant.com/2018/12/29/sublime/sublime-text3-used/</id>
    <published>2018-12-29T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.912Z</updated>
    
    <content type="html"><![CDATA[<p>Sublimetext3 使用</p><a id="more"></a><h2 id="一-设置【Settings】"><a href="#一-设置【Settings】" class="headerlink" title="一. 设置【Settings】"></a>一. 设置【Settings】</h2><ul><li><p>依次单击菜单栏【Perferences】→【Settings】</p></li><li><p>把右边的Setting-User中的内容全部删掉，</p></li><li><p>将左边的Setting-Default里边的内容copy到右边User里，</p></li><li><p>根据需要修改User的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Settings in here override those in &quot;Default/Preferences.sublime-settings&quot;,</span><br><span class="line">// and are overridden in turn by file type specific settings.</span><br><span class="line">&#123;</span><br><span class="line">    &quot;update_check&quot;: false,//(不检查更新)</span><br><span class="line">    &quot;tab_size&quot;: 4,</span><br><span class="line">    &quot;translate_tabs_to_spaces&quot;: true,//(tab转空格)</span><br><span class="line">    &quot;draw_white_space&quot;: &quot;all&quot;,//(显示空格，一般不要用，看这难受)</span><br><span class="line">    &quot;trim_trailing_white_space_on_save&quot;: true, //(保存的时候去掉行尾的空格)</span><br><span class="line">    &quot;highlight_line&quot;:true,//(突出显示当前行)</span><br><span class="line">    &quot;font_size&quot;:15,//(根据个人适应程度来调节吧)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置格式化快捷键</p><blockquote><p>关于sublimeText3 设置格式化代码快捷键的问题<br>sublime中自建的有格式化按钮：<br>Edit  -&gt;  Line  -&gt;  Reindent<br>只是sublime并没有给他赋予快捷键，所以只需加上快捷键即可<br>Preference  -&gt;  Key Bindings -user<br>打开用户快捷键绑定设置添加(比如添加：ctrl + alt + l)</p></blockquote></li></ul><p>注:这里为了和webstorm保持一致就把格式化代码的快捷键设置成ctrl+alt+l</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;keys&quot;: [&quot;ctrl+alt+l&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;,  //注意不要忘记加逗号</span><br></pre></td></tr></table></figure><h2 id="二-安装Package-Control"><a href="#二-安装Package-Control" class="headerlink" title="二. 安装Package Control"></a>二. 安装Package Control</h2><blockquote><p>Package Control为插件管理包，所以我们首先要安装它。有了它，我们就可以很方便的浏览、安装和卸载Sublime Text中的插件。<br> 打开<a href="https://packagecontrol.io/" target="_blank" rel="noopener">Package Control</a> 的网页 ，点击右侧的“Install Now”按钮。</p></blockquote><img src="/2018/12/29/sublime/sublime-text3-used/6_1.jpg" title="Install Now"><blockquote><p>进入<a href="https://packagecontrol.io/installation#st3" target="_blank" rel="noopener">Installation</a> 页面，选择“SUBLIME TEXT 3”选项卡，复制出里面的代码段：</p></blockquote><img src="/2018/12/29/sublime/sublime-text3-used/6_2.jpg" title="“SUBLIME TEXT 3”选项卡"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure><p>双击桌面“Sublime Text 3”打开程序，快捷键 Ctrl + ` 打开Sublime Text控制台，将之前复制的代码粘贴到控制台里，按下“Enter”键。</p><img src="/2018/12/29/sublime/sublime-text3-used/6_3.jpg" title="Sublime Text控制台"><p>等待其安装完成后关闭程序，重新启动“Sublime Text 3”，点开菜单“Preferences”可见“Package Control”项，说明插件管理包已安装成功。</p><img src="/2018/12/29/sublime/sublime-text3-used/6_4.jpg" title="Package Control"><p>网站 packagecontrol.io 经常会挂掉 可以换手动安装</p><p>手动安装：</p><p>可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control：</p><p>1.点击Preferences &gt; Browse Packages菜单</p><p>2.进入打开的目录的上层目录，然后再进入Installed Packages/目录</p><p>3.下载 Package Control.sublime-package 并复制到Installed Packages/目录</p><p>4.重启Sublime Text。</p><p>Package Control <a href="https://github.com/wbond/sublime_package_control" target="_blank" rel="noopener">主文件下载地址</a><br>如果是从github 下载的源码，请解压到Packages下，命名为Package Control就好</p><p>如果需要其他的插件包一样离线安装即可</p><h2 id="快捷键使用"><a href="#快捷键使用" class="headerlink" title="快捷键使用"></a>快捷键使用</h2><h3 id="1-就近选择相同项-ctrl-d"><a href="#1-就近选择相同项-ctrl-d" class="headerlink" title="1. 就近选择相同项: ctrl+d"></a>1. 就近选择相同项: ctrl+d</h3><p>把光标放在一个单词上，按下ctrl+d，将选择这个单词。一直按住ctrl且按D多次，将选择当前选中项的下一个匹配项。通过按住ctrl，再按D三次，将选择三个相同的文本。</p><img src="/2018/12/29/sublime/sublime-text3-used/u_1.gif" title="Image"><h3 id="2-选择当前文件所有匹配项-alt-f3"><a href="#2-选择当前文件所有匹配项-alt-f3" class="headerlink" title="2. 选择当前文件所有匹配项: alt+f3"></a>2. 选择当前文件所有匹配项: alt+f3</h3><p>选择文件中的所有匹配项。小心使用这个，因为它能选择一个文件中的所有匹配项. .</p><img src="/2018/12/29/sublime/sublime-text3-used/u_2.gif" title="Image"><h3 id="3-选择文本的包裹标签-ctrl-shift-（ESC键下面的那个）"><a href="#3-选择文本的包裹标签-ctrl-shift-（ESC键下面的那个）" class="headerlink" title="3. 选择文本的包裹标签: ctrl+shift+` （ESC键下面的那个）"></a>3. 选择文本的包裹标签: ctrl+shift+` （ESC键下面的那个）</h3><p>这是一个法宝。也许你希望所有属性保持不变，但只是想选择标签。这个快捷键为你这样做，会注意到你可以在一次操作多个标签。ps：需要Emmet插件（可以直接到后面看插件的安装）</p><img src="/2018/12/29/sublime/sublime-text3-used/u_3.gif" title="Image"><h3 id="4-向上扩展一层-ctrl-shift-a"><a href="#4-向上扩展一层-ctrl-shift-a" class="headerlink" title="4. 向上扩展一层: ctrl+shift+a"></a>4. 向上扩展一层: ctrl+shift+a</h3><p>如果你把光标放在文本间再按下上面的键将选择文本，就像ctrl+d。但是再次按下它，将选择父容器，再按，将选择父容器的父容器。ps：需要Emmet插件（可以直接到后面看插件的安装）</p><img src="/2018/12/29/sublime/sublime-text3-used/u_4.gif" title="Image"><h3 id="5-选择括号内的内容-ctrl-shift-m"><a href="#5-选择括号内的内容-ctrl-shift-m" class="headerlink" title="5. 选择括号内的内容: ctrl+shift+m"></a>5. 选择括号内的内容: ctrl+shift+m</h3><p>这有助于选择括号之间的一切。同样适用于CSS。</p><img src="/2018/12/29/sublime/sublime-text3-used/u_5.gif" title="Image"><h3 id="6-整行的上下移动-ctrl-shift-↑或-ctrl-shift-↓"><a href="#6-整行的上下移动-ctrl-shift-↑或-ctrl-shift-↓" class="headerlink" title="6. 整行的上下移动: ctrl+shift+↑或 ctrl+shift+↓"></a>6. 整行的上下移动: ctrl+shift+↑或 ctrl+shift+↓</h3><img src="/2018/12/29/sublime/sublime-text3-used/u_6.gif" title="Image"><h3 id="7-复制行或选中项-ctrl-shift-d"><a href="#7-复制行或选中项-ctrl-shift-d" class="headerlink" title="7. 复制行或选中项: ctrl+shift+d"></a>7. 复制行或选中项: ctrl+shift+d</h3><p>如果你已经选中了文本，它会复制你的选中项。否则，把光标放在行上，会复制整行。</p><img src="/2018/12/29/sublime/sublime-text3-used/u_7.gif" title="Image"><h3 id="8-增加和减少缩进-ctrl-或"><a href="#8-增加和减少缩进-ctrl-或" class="headerlink" title="8. 增加和减少缩进: ctrl+[ 或 ]"></a>8. 增加和减少缩进: ctrl+[ 或 ]</h3><img src="/2018/12/29/sublime/sublime-text3-used/u_8.gif" title="Image"><h3 id="9-单行剪辑或选中项-ctrl-x"><a href="#9-单行剪辑或选中项-ctrl-x" class="headerlink" title="9. 单行剪辑或选中项: ctrl+x"></a>9. 单行剪辑或选中项: ctrl+x</h3><img src="/2018/12/29/sublime/sublime-text3-used/u_9.gif" title="Image"><h3 id="10-粘贴并复制格式-ctrl-shift-v"><a href="#10-粘贴并复制格式-ctrl-shift-v" class="headerlink" title="10. 粘贴并复制格式: ctrl+shift+v"></a>10. 粘贴并复制格式: ctrl+shift+v</h3><img src="/2018/12/29/sublime/sublime-text3-used/u_10.gif" title="Image"><h3 id="11-用标签包裹行或选中项-alt-shift-w"><a href="#11-用标签包裹行或选中项-alt-shift-w" class="headerlink" title="11. 用标签包裹行或选中项: alt+shift+w"></a>11. 用标签包裹行或选中项: alt+shift+w</h3><img src="/2018/12/29/sublime/sublime-text3-used/u_11.gif" title="Image"><h3 id="12-移除未闭合的容器元素-ctrl-shift"><a href="#12-移除未闭合的容器元素-ctrl-shift" class="headerlink" title="12. 移除未闭合的容器元素: ctrl+shift+;"></a>12. 移除未闭合的容器元素: ctrl+shift+;</h3><p>这会移除与你的光标相关的父标签。对清除标记很有帮助。</p><img src="/2018/12/29/sublime/sublime-text3-used/u_12.gif" title="Image"><h3 id="13-大写和小写-大写ctrl-k-u、小写ctrl-k-l"><a href="#13-大写和小写-大写ctrl-k-u、小写ctrl-k-l" class="headerlink" title="13. 大写和小写: 大写ctrl+k+u、小写ctrl+k+l"></a>13. 大写和小写: 大写ctrl+k+u、小写ctrl+k+l</h3><img src="/2018/12/29/sublime/sublime-text3-used/u_13.gif" title="Image"><h3 id="14-注释选中项-行-ctrl"><a href="#14-注释选中项-行-ctrl" class="headerlink" title="14. 注释选中项/行: ctrl+/"></a>14. 注释选中项/行: ctrl+/</h3><p>这个在所有语言下都可用， 对行和选中项都可用</p><img src="/2018/12/29/sublime/sublime-text3-used/u_14.gif" title="Image"><h3 id="15-删除一行-ctrl-shift-k"><a href="#15-删除一行-ctrl-shift-k" class="headerlink" title="15. 删除一行: ctrl+shift+k"></a>15. 删除一行: ctrl+shift+k</h3><blockquote><p>这个就不用图了吧</p></blockquote><h3 id="16-sublime查找替换-ctrl-f-ctrl-h"><a href="#16-sublime查找替换-ctrl-f-ctrl-h" class="headerlink" title="16. sublime查找替换: ctrl+f / ctrl+h"></a>16. sublime查找替换: ctrl+f / ctrl+h</h3><blockquote><p>如果要替换换行符<br> 要先选中正则表达式（regular expression）匹配模式，点中（.*）按钮<br>输入 \n</p></blockquote><p>参考来源于：</p><p><a href="https://www.cnblogs.com/wind128/p/4409422.html" target="_blank" rel="noopener">https://www.cnblogs.com/wind128/p/4409422.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sublimetext3 使用&lt;/p&gt;
    
    </summary>
    
      <category term="sublime" scheme="http://blog.rcant.com/categories/sublime/"/>
    
    
      <category term="sublime text3" scheme="http://blog.rcant.com/tags/sublime-text3/"/>
    
  </entry>
  
  <entry>
    <title>python3 包介绍</title>
    <link href="http://blog.rcant.com/2018/12/26/python/python3-pkg/"/>
    <id>http://blog.rcant.com/2018/12/26/python/python3-pkg/</id>
    <published>2018-12-26T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.907Z</updated>
    
    <content type="html"><![CDATA[<p>想了解下pip工作原理<br>已经python的包的引入逻辑</p><a id="more"></a><h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PKG-INFO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Metadata-Version: 1.0</span><br><span class="line">Name: txrestapi</span><br><span class="line">Version: 0.2</span><br><span class="line">Summary: Easing the creation of REST API services in Python</span><br><span class="line">Home-page: http://github.com/iancmcc/txrestapi</span><br><span class="line">Author: Ian McCracken</span><br><span class="line">Author-email: ian.mccracken@gmail.com</span><br><span class="line">License: MIT</span><br><span class="line">Description: UNKNOWN</span><br><span class="line">Platform: UNKNOWN</span><br></pre></td></tr></table></figure><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><p>有 input 和 raw_input 两个函数 </p><h4 id="input-传入值的时候-会区别-类型"><a href="#input-传入值的时候-会区别-类型" class="headerlink" title="input 传入值的时候 会区别 类型"></a>input 传入值的时候 会区别 类型</h4><p>传值给a ，1的时候，a的值就为1,为数值型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = input(&quot;input:&quot;)</span><br><span class="line">input:1</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>传给a HHH 的时候会报错，因为没有定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = input(&quot;input:&quot;)</span><br><span class="line">input:HHH</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;HHH&apos; is not defined</span><br></pre></td></tr></table></figure><p>如果要传字符串要用 “HHH”，这个时候a为字符串变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = input(&quot;input:&quot;)</span><br><span class="line">input:&quot;HHH&quot;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;HHH&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="raw-input-传递进去的统一被认为字符串"><a href="#raw-input-传递进去的统一被认为字符串" class="headerlink" title="raw_input 传递进去的统一被认为字符串"></a>raw_input 传递进去的统一被认为字符串</h4><p>传值给a ，1的时候，a的值为1,为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = raw_input(&quot;input:&quot;)</span><br><span class="line">input:1</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;1&apos;</span><br></pre></td></tr></table></figure><p>传值给a ，HHH的时候，a的值为HHH,也是为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = raw_input(&quot;input:&quot;)</span><br><span class="line">input:HHH</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;HHH&apos;</span><br></pre></td></tr></table></figure><p>传值给a ，”HHH” 的时候，a的值为”HHH”,也是为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = raw_input(&quot;input:&quot;)</span><br><span class="line">input:&quot;HHH&quot;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;&quot;HHH&quot;&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><p>只保留了 input 函数<br>而且这个函数和 python2里面的raw_input 是一个意思</p><p>一个 python 程序输入两个值进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">a = input(&quot;please input a: &quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Input A:&#123;0&#125;&quot;.format(a))</span><br><span class="line"></span><br><span class="line">b = input(&quot;please input b: &quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Input B:&#123;0&#125;&quot;.format(b))</span><br><span class="line"></span><br><span class="line">print(&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;.format(a,b,a*b))</span><br></pre></td></tr></table></figure><p>Python2 的结果是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[web@localhost 1.1]$ python2 calc.py</span><br><span class="line">please input a: 1</span><br><span class="line">Input A:1</span><br><span class="line">please input b: 1</span><br><span class="line">Input B:1</span><br><span class="line">1 * 1 = 1</span><br></pre></td></tr></table></figure><p>Python3 的结果是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[web@localhost 1.1]$ python3 calc.py</span><br><span class="line">please input a: 1</span><br><span class="line">Input A:1</span><br><span class="line">please input b: 1</span><br><span class="line">Input B:1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;calc.py&quot;, line 12, in &lt;module&gt;</span><br><span class="line">    print(&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;.format(a,b,a*b))</span><br><span class="line">TypeError: can&apos;t multiply sequence by non-int of type &apos;str&apos;</span><br></pre></td></tr></table></figure><p>不能用字符串进行乘法运算</p><p>说明python3的input 函数接受的是字符串</p><p>需要对字符串进行转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">a = input(&quot;please input a: &quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Input A:&#123;0&#125;&quot;.format(a))</span><br><span class="line"></span><br><span class="line">b = input(&quot;please input b: &quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Input B:&#123;0&#125;&quot;.format(b))</span><br><span class="line"></span><br><span class="line">print(&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;.format(a,b,int(a)*int(b))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想了解下pip工作原理&lt;br&gt;已经python的包的引入逻辑&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.rcant.com/categories/python/"/>
    
    
      <category term="python3" scheme="http://blog.rcant.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>Django 1.10 升级到 2.1的问题</title>
    <link href="http://blog.rcant.com/2018/12/24/django/django-1to2/"/>
    <id>http://blog.rcant.com/2018/12/24/django/django-1to2/</id>
    <published>2018-12-24T03:39:17.000Z</published>
    <updated>2020-08-07T02:31:56.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>之前写的一些东西时间有点久了，想升级一下Django版本</p><a id="more"></a><h3 id="升级Django"><a href="#升级Django" class="headerlink" title="升级Django"></a>升级Django</h3><p>requestments.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Django&gt;=2.0,&lt;3.0</span><br><span class="line">mysqlclient</span><br><span class="line">psycopg2</span><br><span class="line">djangorestframework</span><br><span class="line">markdown</span><br><span class="line">django-filter</span><br><span class="line">django-allauth</span><br><span class="line">django-bootstrap3</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requestments.txt</span><br></pre></td></tr></table></figure><h3 id="尝试运行-runserver"><a href="#尝试运行-runserver" class="headerlink" title="尝试运行 runserver"></a>尝试运行 runserver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./manage.py runserver localhost:5000</span><br></pre></td></tr></table></figure><p>发现以下问题</p><h4 id="1-外键关联语法错误"><a href="#1-外键关联语法错误" class="headerlink" title="1. 外键关联语法错误"></a>1. 外键关联语法错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  File &quot;E:\projects\python\dweb\web\smanager\models.py&quot;, line 50, in Employee</span><br><span class="line">    user = models.OneToOneField(User)</span><br><span class="line">TypeError: __init__() missing 1 required positional argument: &apos;on_delete&apos;</span><br></pre></td></tr></table></figure><p>原因：</p><p>在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：<br>TypeError: <strong>init</strong>() missing 1 required positional argument: ‘on_delete’<br>举例说明：<br>user=models.OneToOneField(User)<br>owner=models.ForeignKey(UserProfile)<br>需要改成：<br>user=models.OneToOneField(User,on_delete=models.CASCADE) –在老版本这个参数（models.CASCADE）是默认值<br>owner=models.ForeignKey(UserProfile,on_delete=models.CASCADE) –在老版本这个参数（models.CASCADE）是默认值<br>参数说明：<br>on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值<br>CASCADE：此值设置，是级联删除。<br>PROTECT：此值设置，是会报完整性错误。<br>SET_NULL：此值设置，会把外键设置为null，前提是允许为null。<br>SET_DEFAULT：此值设置，会把设置为外键的默认值。<br>SET()：此值设置，会调用外面的值，可以是一个函数。<br>一般情况下使用CASCADE就可以了。</p><p>修改：</p><p>即在外键值的后面加上 on_delete=models.CASCADE</p><h4 id="2-引入包名错误"><a href="#2-引入包名错误" class="headerlink" title="2. 引入包名错误"></a>2. 引入包名错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 994, in _gcd_import</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 971, in _find_and_load</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 955, in _find_and_load_unlocked</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 665, in _load_unlocked</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 678, in exec_module</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed</span><br><span class="line">  File &quot;E:\projects\python\dweb\web\smonitor\urls.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    from smanager import views as sm_views</span><br><span class="line">  File &quot;E:\projects\python\dweb\web\smanager\views.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    from django.core.urlresolvers import reverse</span><br><span class="line">ModuleNotFoundError: No module named &apos;django.core.urlresolvers&apos;</span><br></pre></td></tr></table></figure><p>原因： </p><p>django.core.urlresolvers 在 Django2中被修改，可以找 django.urls </p><p>修改 ：<br>from django.core.urlresolvers import reverse -&gt; from django.urls import reverse</p><h4 id="3-启动服务之前需要首先运行python-manage-py-migrate"><a href="#3-启动服务之前需要首先运行python-manage-py-migrate" class="headerlink" title="3. 启动服务之前需要首先运行python manage.py migrate"></a>3. 启动服务之前需要首先运行python manage.py migrate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.</span><br><span class="line">Run &apos;python manage.py migrate&apos; to apply them.</span><br></pre></td></tr></table></figure><h4 id="4-运行时错误"><a href="#4-运行时错误" class="headerlink" title="4. 运行时错误"></a>4. 运行时错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Internal Server Error: /</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\apps\python36\lib\site-packages\django\core\handlers\exception.py&quot;, line 34, in inner</span><br><span class="line">    response = get_response(request)</span><br><span class="line">  File &quot;D:\apps\python36\lib\site-packages\django\core\handlers\base.py&quot;, line 126, in _get_response</span><br><span class="line">    response = self.process_exception_by_middleware(e, request)</span><br><span class="line">  File &quot;D:\apps\python36\lib\site-packages\django\core\handlers\base.py&quot;, line 124, in _get_response</span><br><span class="line">    response = wrapped_callback(request, *callback_args, **callback_kwargs)</span><br><span class="line">  File &quot;E:\projects\python\dweb\web\smanager\views.py&quot;, line 27, in index</span><br><span class="line">    if request.user.is_authenticated() == False :</span><br><span class="line">TypeError: &apos;bool&apos; object is not callable</span><br></pre></td></tr></table></figure><p>方法修改成属性  request.user.is_authenticated() –&gt; request.user.is_authenticated</p><p>‘WSGIRequest’ object has no attribute ‘session’，这个问题是因为settings中middleware的定义参数变了，得把MIDDLEWARE_ClASSES改成MIDDLEWARE。</p><h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p>其他注意事项</p><p>MIDDLEWARE:<br>新版本中 中间件的key值 由 MIDDLEWARE_CLASSES 变更为 MIDDLEWARE</p><p>render_to_response：<br>新版本中 render_to_response 不建议使用，替换为render</p><p>dict的’has_key’方法弃用:<br>新版python字典 has_key 方法取消，建议使用 “str” in dict 判断</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;之前写的一些东西时间有点久了，想升级一下Django版本&lt;/p&gt;
    
    </summary>
    
      <category term="django" scheme="http://blog.rcant.com/categories/django/"/>
    
    
      <category term="django" scheme="http://blog.rcant.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 403 (Permission denied)</title>
    <link href="http://blog.rcant.com/2018/10/08/others/nginx-403/"/>
    <id>http://blog.rcant.com/2018/10/08/others/nginx-403/</id>
    <published>2018-10-08T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.900Z</updated>
    
    <content type="html"><![CDATA[<p>解决Nginx 403报错问题</p><a id="more"></a><h2 id="查看Nginx日志"><a href="#查看Nginx日志" class="headerlink" title="查看Nginx日志"></a>查看Nginx日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/log/nginx/error.log</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> open() &quot;/data/www/1.txt&quot; failed (13: Permission denied), client: 192.168.1.194, server: www.web1.com, request: &quot;GET /1.txt HTTP/1.1&quot;, host: &quot;www.web1.com&quot;</span><br></pre></td></tr></table></figure><p>打开日志发现报错Permission denied</p><h2 id="排查方式"><a href="#排查方式" class="headerlink" title="排查方式"></a>排查方式</h2><h3 id="一、由于启动用户和nginx工作用户不一致所致"><a href="#一、由于启动用户和nginx工作用户不一致所致" class="headerlink" title="一、由于启动用户和nginx工作用户不一致所致"></a>一、由于启动用户和nginx工作用户不一致所致</h3><h4 id="查看nginx的启动用户，发现是nobody，而为是用root启动的"><a href="#查看nginx的启动用户，发现是nobody，而为是用root启动的" class="headerlink" title="查看nginx的启动用户，发现是nobody，而为是用root启动的"></a>查看nginx的启动用户，发现是nobody，而为是用root启动的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep &quot;nginx: worker process&quot; | awk&apos;&#123;print $1&#125;&apos;</span><br></pre></td></tr></table></figure><h4 id="将nginx-config的user改为和启动用户一致"><a href="#将nginx-config的user改为和启动用户一致" class="headerlink" title="将nginx.config的user改为和启动用户一致"></a>将nginx.config的user改为和启动用户一致</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi conf/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="二、权限问题"><a href="#二、权限问题" class="headerlink" title="二、权限问题"></a>二、权限问题</h3><p>如果nginx没有web目录的操作权限，也会出现403错误</p><p>解决办法：修改web目录的读写权限，或者是把nginx的启动用户改成目录的所属用户，重启Nginx即可解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /data</span><br><span class="line">chmod -R 777 /data/www/</span><br></pre></td></tr></table></figure><h3 id="三、-SELinux设置为开启状态（enabled）的原因"><a href="#三、-SELinux设置为开启状态（enabled）的原因" class="headerlink" title="三、 SELinux设置为开启状态（enabled）的原因"></a>三、 SELinux设置为开启状态（enabled）的原因</h3><h4 id="查看当前selinux的状态"><a href="#查看当前selinux的状态" class="headerlink" title="查看当前selinux的状态"></a>查看当前selinux的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/sestatus</span><br></pre></td></tr></table></figure><h4 id="将SELINUX-enforcing-修改为-SELINUX-disabled-状态。"><a href="#将SELINUX-enforcing-修改为-SELINUX-disabled-状态。" class="headerlink" title="将SELINUX=enforcing 修改为 SELINUX=disabled 状态。"></a>将SELINUX=enforcing 修改为 SELINUX=disabled 状态。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#SELINUX=enforcing</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><h4 id="重启生效"><a href="#重启生效" class="headerlink" title="重启生效"></a>重启生效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决Nginx 403报错问题&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://blog.rcant.com/categories/web/"/>
    
    
      <category term="nginx" scheme="http://blog.rcant.com/tags/nginx/"/>
    
      <category term="web" scheme="http://blog.rcant.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Centos 安装 ShadowSocks 并实现全局代理</title>
    <link href="http://blog.rcant.com/2018/09/20/centos/centos-ShadowSocks/"/>
    <id>http://blog.rcant.com/2018/09/20/centos/centos-ShadowSocks/</id>
    <published>2018-09-20T06:40:07.000Z</published>
    <updated>2020-08-07T02:31:56.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>CentOS 使用 ShadowSocks</p><a id="more"></a><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install epel-release #首先安装epel扩展源：</span><br><span class="line">sudo yum -y install python-pip #安装完扩展源后安装python-pip</span><br><span class="line">sudo yum clean all #安装完清除cache</span><br></pre></td></tr></table></figure><h2 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h2 id="配置Shadowsocks"><a href="#配置Shadowsocks" class="headerlink" title="配置Shadowsocks"></a>配置Shadowsocks</h2><p>新建一个/etc/shadowsocks.json文件，里面写上如下配置</p><p>中文删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;your_server_ip&quot;, </span><br><span class="line">#ss服务器IP</span><br><span class="line">&quot;server_port&quot;:your_server_port,</span><br><span class="line">#端口</span><br><span class="line">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">#本地ip</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">#本地端口</span><br><span class="line">&quot;password&quot;:&quot;your_server_passwd&quot;,</span><br><span class="line">#连接ss密码</span><br><span class="line">&quot;timeout&quot;:300,</span><br><span class="line">#等待超时</span><br><span class="line">&quot;method&quot;:&quot;rc4-md5&quot;,</span><br><span class="line">#加密方式</span><br><span class="line">&quot;fast_open&quot;: false,</span><br><span class="line">#true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &amp;gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可</span><br><span class="line">&quot;workers&quot;: 1</span><br><span class="line">#工作线程数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 Shadowsocks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><h2 id="使用-Privoxy-转发"><a href="#使用-Privoxy-转发" class="headerlink" title="使用 Privoxy 转发"></a>使用 Privoxy 转发</h2><h3 id="安装Privoxy"><a href="#安装Privoxy" class="headerlink" title="安装Privoxy"></a>安装Privoxy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y privoxy</span><br></pre></td></tr></table></figure><h3 id="配置Privoxy"><a href="#配置Privoxy" class="headerlink" title="配置Privoxy"></a>配置Privoxy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加本地ssr服务到配置文件</span><br><span class="line">echo &apos;forward-socks5 / 127.0.0.1:1080 .&apos; &gt;&gt; /etc/privoxy/config</span><br><span class="line"># Privoxy 默认监听端口是是8118</span><br><span class="line">export http_proxy=http://127.0.0.1:8118</span><br><span class="line">export https_proxy=http://127.0.0.1:8118</span><br><span class="line">export no_proxy=localhost</span><br><span class="line"># 启动服务</span><br><span class="line">systemctl start privoxy.service</span><br></pre></td></tr></table></figure><p>取消代理设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#停止服务</span><br><span class="line">systemctl stop privoxy.service</span><br><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br><span class="line">unset no_proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;CentOS 使用 ShadowSocks&lt;/p&gt;
    
    </summary>
    
      <category term="centos" scheme="http://blog.rcant.com/categories/centos/"/>
    
    
      <category term="centos" scheme="http://blog.rcant.com/tags/centos/"/>
    
      <category term="shadowsocks" scheme="http://blog.rcant.com/tags/shadowsocks/"/>
    
  </entry>
  
</feed>
